<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EnTT<span id="projectnumber">&#160;3.15.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">entt Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>EnTT</code> default namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1adjacency__matrix.html">adjacency_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a directed adjacency matrix.  <a href="classentt_1_1adjacency__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1adl__meta__pointer__like.html">adl_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake ADL based lookup function for meta pointer-like types.  <a href="structentt_1_1adl__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1allocation__deleter.html">allocation_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter for allocator-aware unique pointers (waiting for C++20).  <a href="structentt_1_1allocation__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__cref__t.html">as_cref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as cref</em> policy.  <a href="structentt_1_1as__cref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1as__group.html">as_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a group.  <a href="classentt_1_1as__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__is__t.html">as_is_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as-is</em> policy.  <a href="structentt_1_1as__is__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__ref__t.html">as_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as ref</em> policy.  <a href="structentt_1_1as__ref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1as__view.html">as_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a view.  <a href="classentt_1_1as__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__void__t.html">as_void_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as void</em> policy.  <a href="structentt_1_1as__void__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__any.html">basic_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SBO friendly, type-safe container for single values of any type.  <a href="classentt_1_1basic__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__common__view.html">basic_common_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage view implementation.  <a href="classentt_1_1basic__common__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for <em>continuous loading</em>.  <a href="classentt_1_1basic__continuous__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__dispatcher.html">basic_dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic dispatcher implementation.  <a href="classentt_1_1basic__dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__entt__traits.html">basic_entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common basic entity traits implementation.  <a href="classentt_1_1basic__entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__flow.html">basic_flow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating task graphs.  <a href="classentt_1_1basic__flow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group.html">basic_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group.  <a href="classentt_1_1basic__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01owned__t_3_01Owned_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_00_011bc3c06bb47de7bb72ca45b6e209ac72.html">basic_group&lt; owned_t&lt; Owned... &gt;, get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning group.  <a href="classentt_1_1basic__group_3_01owned__t_3_01Owned_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_00_011bc3c06bb47de7bb72ca45b6e209ac72.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01owned__t_3_4_00_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html">basic_group&lt; owned_t&lt;&gt;, get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning group.  <a href="classentt_1_1basic__group_3_01owned__t_3_4_00_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__handle.html">basic_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning handle to an entity.  <a href="classentt_1_1basic__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero overhead unique identifier.  <a href="classentt_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__meta__associative__container__traits.html">basic_meta_associative_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose implementation of meta associative container traits.  <a href="structentt_1_1basic__meta__associative__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__meta__sequence__container__traits.html">basic_meta_sequence_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose implementation of meta sequence container traits.  <a href="structentt_1_1basic__meta__sequence__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating a static task graph.  <a href="classentt_1_1basic__organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__poly.html">basic_poly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static polymorphism made simple and within everyone's reach.  <a href="classentt_1_1basic__poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__reactive__mixin.html">basic_reactive_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type used to add <em>reactive</em> support to storage types.  <a href="classentt_1_1basic__reactive__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast and reliable entity-component system.  <a href="classentt_1_1basic__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic runtime view.  <a href="classentt_1_1basic__runtime__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__scheduler.html">basic_scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooperative scheduler for processes.  <a href="classentt_1_1basic__scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sigh__mixin.html">basic_sigh_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type used to add signal support to storage types.  <a href="classentt_1_1basic__sigh__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create snapshots from a registry.  <a href="classentt_1_1basic__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to restore a snapshot as a whole.  <a href="classentt_1_1basic__snapshot__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse set implementation.  <a href="classentt_1_1basic__sparse__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage implementation.  <a href="classentt_1_1basic__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Entity_00_01Allocator_01_4.html">basic_storage&lt; Entity, Entity, Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap-only entity storage specialization.  <a href="classentt_1_1basic__storage_3_01Entity_00_01Entity_00_01Allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage_3_01Type_00_01Entity_00_01Allocator_00_01std_1_1enable__if__t_3_01codc425495d57bad12d99123a94a344005.html">basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; component_traits&lt; Type, Entity &gt;::page_size==0u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.     <a href="classentt_1_1basic__storage_3_01Type_00_01Entity_00_01Allocator_00_01std_1_1enable__if__t_3_01codc425495d57bad12d99123a94a344005.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage__view.html">basic_storage_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage view implementation.  <a href="classentt_1_1basic__storage__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__table.html">basic_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic table implementation.  <a href="classentt_1_1basic__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view.html">basic_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View implementation.  <a href="classentt_1_1basic__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01get__t_3_01Get_01_4_00_01exclude__t_3_4_01_4.html">basic_view&lt; get_t&lt; Get &gt;, exclude_t&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage view specialization.  <a href="classentt_1_1basic__view_3_01get__t_3_01Get_01_4_00_01exclude__t_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_00bfe15740605f6adb254763e866b0aef8.html">basic_view&lt; get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt;, std::enable_if_t&lt;(sizeof...(Get) !=0u)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose view.  <a href="classentt_1_1basic__view_3_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_00bfe15740605f6adb254763e866b0aef8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t.html">choice_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t_3_010_01_4.html">choice_t&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.     <a href="structentt_1_1choice__t_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1component__traits.html">component_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common way to access various properties of components.  <a href="structentt_1_1component__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compressed pair.  <a href="classentt_1_1compressed__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag for constructors and the like.  <a href="structentt_1_1connect__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection class.  <a href="classentt_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as.html">constness_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html">constness_as&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.     <a href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic delegate implementation.  <a href="classentt_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>delegate&lt; Ret(Args...)&gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to use to send around functions and members. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dense__map.html">dense_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container for key-value pairs with unique keys.  <a href="classentt_1_1dense__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dense__set.html">dense_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container for unique objects of a given type.  <a href="classentt_1_1dense__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1directed__tag.html">directed_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undirected graph category tag.  <a href="structentt_1_1directed__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1emitter.html">emitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose event emitter.  <a href="classentt_1_1emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits.html">entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <a href="structentt_1_1entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable bitmask support for enum classes.  <a href="structentt_1_1enum__as__bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1enum__as__bitmask_3_01Type_00_01std_1_1void__t_3_01decltype_07Type_1_1__entt__enum__as__bitmask_08_4_01_4.html">enum_as_bitmask&lt; Type, std::void_t&lt; decltype(Type::_entt_enum_as_bitmask)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable bitmask support for enum classes.     <a href="structentt_1_1enum__as__bitmask_3_01Type_00_01std_1_1void__t_3_01decltype_07Type_1_1__entt__enum__as__bitmask_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1exclude__t.html">exclude_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for exclusion lists.  <a href="structentt_1_1exclude__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1family.html">family</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic identifier generator.  <a href="classentt_1_1family.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1forward__apply.html">forward_apply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to forward-and-apply tuple objects.  <a href="structentt_1_1forward__apply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1get__t.html">get_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of observed elements.  <a href="structentt_1_1get__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1ident.html">ident</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type integral identifiers.  <a href="classentt_1_1ident.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object (waiting for C++20).  <a href="structentt_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1input__iterator__pointer.html">input_iterator_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to use as pointer with input iterators.  <a href="structentt_1_1input__iterator__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1insertion__sort.html">insertion_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing insertion sort.  <a href="structentt_1_1insertion__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain iota iterator (waiting for C++20).  <a href="classentt_1_1iota__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable.html">is_applicable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, const Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.     <a href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.     <a href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable_r&lt; Ret, Func, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.     <a href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete.html">is_complete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">is_complete&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.     <a href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is both an empty and non-final class, false otherwise.  <a href="structentt_1_1is__ebco__eligible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable_3_01const_01Type_01_4.html">is_equality_comparable&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.     <a href="structentt_1_1is__equality__comparable_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator_3_01Type_00_01std_1_1enable__if__t_3_9std_1_1is__void__v_3_01std_1_1r2784f1f1943c3c544a328e35ff343041.html">is_iterator&lt; Type, std::enable_if_t&lt;!std::is_void_v&lt; std::remove_cv_t&lt; std::remove_pointer_t&lt; Type &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.     <a href="structentt_1_1is__iterator_3_01Type_00_01std_1_1enable__if__t_3_9std_1_1is__void__v_3_01std_1_1r2784f1f1943c3c544a328e35ff343041.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a pointer-like type from the point of view of the meta system, false otherwise.  <a href="structentt_1_1is__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html">is_meta_pointer_like&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization to ensure that const pointer-like types are also accepted.  <a href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html">is_meta_pointer_like&lt; std::shared_ptr&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::shared_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html">is_meta_pointer_like&lt; std::unique_ptr&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::unique_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html">is_meta_pointer_like&lt; Type * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes plain pointers pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html">is_meta_pointer_like&lt; Type(*)[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization used to reject pointers to arrays.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__meta__pointer__like_01_4_01_4.html">is_meta_pointer_like&lt; Type, std::void_t&lt; typename Type::is_meta_pointer_like &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for self-proclaimed meta pointer like types.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__meta__pointer__like_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__policy.html">is_meta_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type also is a meta policy, false otherwise.  <a href="structentt_1_1is__meta__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__transparent.html">is_transparent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if <code>Type::is_transparent</code> is valid and denotes a type, false otherwise.  <a href="structentt_1_1is__transparent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__transparent_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__transparent_01_4_01_4.html">is_transparent&lt; Type, std::void_t&lt; typename Type::is_transparent &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if <code>Type::is_transparent</code> is valid and denotes a type, false otherwise.     <a href="structentt_1_1is__transparent_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__transparent_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a tuple, false otherwise.  <a href="structentt_1_1is__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__tuple_3_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a tuple, false otherwise.     <a href="structentt_1_1is__tuple_3_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create an iterable object from a pair of iterators.  <a href="structentt_1_1iterable__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1locator.html">locator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service locator, nothing more.  <a href="classentt_1_1locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1member__class.html">member_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class of a non-static member object or function.  <a href="classentt_1_1member__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for values of any type.  <a href="classentt_1_1meta__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__associative__container.html">meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for associative containers.  <a href="classentt_1_1meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits.html">meta_associative_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta associative containers.  <a href="structentt_1_1meta__associative__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01dense__map_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; dense_map&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code><a class="el" href="classentt_1_1dense__map.html" title="Associative container for key-value pairs with unique keys.">dense_map</a></code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01dense__map_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01dense__set_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; dense_set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code><a class="el" href="classentt_1_1dense__set.html" title="Associative container for unique objects of a given type.">dense_set</a></code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01dense__set_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::map&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_map&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__class__template__tag.html">meta_class_template_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate class templates.  <a href="structentt_1_1meta__class__template__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque meta context type.  <a href="classentt_1_1meta__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__ctx__arg__t.html">meta_ctx_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag for constructors and the like.  <a href="classentt_1_1meta__ctx__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__custom.html">meta_custom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for user defined data of any type.  <a href="structentt_1_1meta__custom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__data.html">meta_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for data members.  <a href="structentt_1_1meta__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__factory.html">meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta factory to be used for reflection purposes.  <a href="classentt_1_1meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__func.html">meta_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for member functions.  <a href="structentt_1_1meta__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor.html">meta_function_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1meta__function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_01Class_1_1_5_01_4.html">meta_function_descriptor&lt; Type, Ret Class::* &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_01Class_1_1_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07_08_4.html">meta_function_descriptor&lt; Type, Ret(*)()&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07MaybeType_00_01Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(*)(MaybeType, Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07MaybeType_00_01Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor__traits.html">meta_function_descriptor_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor traits.  <a href="structentt_1_1meta__function__descriptor__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function helper.  <a href="classentt_1_1meta__function__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointers to instances of any type.  <a href="structentt_1_1meta__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__sequence__container.html">meta_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for sequence containers.  <a href="classentt_1_1meta__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits.html">meta_sequence_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta sequence containers.  <a href="structentt_1_1meta__sequence__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html">meta_sequence_container_traits&lt; std::array&lt; Type, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::array</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1deque_3_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::deque&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::deque</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1deque_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1list_3_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::list&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::list</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1list_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::vector&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::vector</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits.html">meta_template_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta template information.  <a href="structentt_1_1meta__template__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html">meta_template_traits&lt; Clazz&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose traits class for generating meta template information.  <a href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__type.html">meta_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for types.  <a href="classentt_1_1meta__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of the monostate pattern.  <a href="structentt_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1nth__argument.html">nth_argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the n-th argument of a <em>callable</em> type.  <a href="classentt_1_1nth__argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1null__t.html">null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null object for all identifiers.  <a href="structentt_1_1null__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for visitors.  <a href="structentt_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1owned__t.html">owned_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of owned elements.  <a href="structentt_1_1owned__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__base.html">poly_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poly base class used to inject functionalities into concepts.  <a href="structentt_1_1poly__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__inspector.html">poly_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector class used to infer the type of the virtual table.  <a href="structentt_1_1poly__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1poly__vtable.html">poly_vtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static virtual table factory.  <a href="classentt_1_1poly__vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1process.html">process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for processes.  <a href="classentt_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1process__adaptor.html">process_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for lambdas and functors to turn them into processes.  <a href="structentt_1_1process__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1radix__sort.html">radix_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing LSD radix sort.  <a href="structentt_1_1radix__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1reactive.html">reactive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty value type for reactive storage types.  <a href="structentt_1_1reactive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource.html">resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic resource handle.  <a href="classentt_1_1resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__cache.html">resource_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic cache for resources of any type.  <a href="classentt_1_1resource__cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1resource__loader.html">resource_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent loader for shared resources.  <a href="structentt_1_1resource__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1scoped__connection.html">scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped connection class.  <a href="structentt_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh.html">sigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>sigh&lt; Ret(Args...), Allocator &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1sigh__helper.html">sigh_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1sigh__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1sigh__helper_3_01Registry_01_4.html">sigh_helper&lt; Registry &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal connection helper for registries.  <a href="structentt_1_1sigh__helper_3_01Registry_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1sigh__helper_3_01Registry_00_01Type_01_4.html">sigh_helper&lt; Registry, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal connection helper for registries.  <a href="structentt_1_1sigh__helper_3_01Registry_00_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>sink&lt; sigh&lt; Ret(Args...), Allocator &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of.html">size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">size_of&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.     <a href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1std__sort.html">std_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to wrap <code>std::sort</code> in a class type.  <a href="structentt_1_1std__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__for.html">storage_for</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__type.html">storage_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a common way to define storage types.  <a href="structentt_1_1storage__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__type_3_01reactive_00_01Entity_00_01Allocator_01_4.html">storage_type&lt; reactive, Entity, Allocator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tombstone object for all identifiers.  <a href="structentt_1_1tombstone__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__hash.html">type_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type hash.  <a href="structentt_1_1type__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity type trait.  <a href="structentt_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__index.html">type_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type sequential identifier.  <a href="structentt_1_1type__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation specific information about a type.  <a href="structentt_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of types, nothing more.  <a href="structentt_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_4.html">type_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html">type_list_contains&lt; type_list&lt; Type... &gt;, Other &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.     <a href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html">type_list_diff&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two type lists.  <a href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element.html">type_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; 0u, type_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; Index, type_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index.html">type_list_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">type_list_index&lt; Type, type_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the types of a type list.  <a href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_index&lt; Type, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the types of a type list.  <a href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_4_01_4.html">type_list_index&lt; Type, type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the types of a type list.  <a href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform.html">type_list_transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform_3_01exclude__t_3_01Type_8_8_8_01_4_00_01Op_01_4.html">type_list_transform&lt; exclude_t&lt; Type... &gt;, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given <em>function</em> to an exclude list and generate a new list.  <a href="structentt_1_1type__list__transform_3_01exclude__t_3_01Type_8_8_8_01_4_00_01Op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform_3_01get__t_3_01Type_8_8_8_01_4_00_01Op_01_4.html">type_list_transform&lt; get_t&lt; Type... &gt;, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given <em>function</em> to a get list and generate a new list.  <a href="structentt_1_1type__list__transform_3_01get__t_3_01Type_8_8_8_01_4_00_01Op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform_3_01owned__t_3_01Type_8_8_8_01_4_00_01Op_01_4.html">type_list_transform&lt; owned_t&lt; Type... &gt;, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given <em>function</em> to an owned list and generate a new list.  <a href="structentt_1_1type__list__transform_3_01owned__t_3_01Type_8_8_8_01_4_00_01Op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform_3_01type__list_3_01Type_8_8_8_01_4_00_01Op_01_4.html">type_list_transform&lt; type_list&lt; Type... &gt;, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given <em>function</em> to a type list and generate a new list.  <a href="structentt_1_1type__list__transform_3_01type__list_3_01Type_8_8_8_01_4_00_01Op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__name.html">type_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type name.  <a href="structentt_1_1type__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1undirected__tag.html">undirected_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directed graph category tag.  <a href="structentt_1_1undirected__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list.html">value_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of constant values, nothing more.  <a href="structentt_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt;, value_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_4.html">value_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__contains.html">value_list_contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a value list contains a given value, false otherwise.  <a href="structentt_1_1value__list__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__contains_3_01value__list_3_01Value_8_8_8_01_4_00_01Other_01_4.html">value_list_contains&lt; value_list&lt; Value... &gt;, Other &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a value list contains a given value, false otherwise.     <a href="structentt_1_1value__list__contains_3_01value__list_3_01Value_8_8_8_01_4_00_01Other_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__diff.html">value_list_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__diff_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_01_4.html">value_list_diff&lt; value_list&lt; Value... &gt;, value_list&lt; Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two value lists.  <a href="structentt_1_1value__list__diff_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element.html">value_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; 0u, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; Index, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the values of a value list.  <a href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__index.html">value_list_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__index_3_01Value_00_01value__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">value_list_index&lt; Value, value_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the values of a value list.  <a href="structentt_1_1value__list__index_3_01Value_00_01value__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__index_3_01Value_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_index&lt; Value, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the values of a value list.  <a href="structentt_1_1value__list__index_3_01Value_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__index_3_01Value_00_01value__list_3_4_01_4.html">value_list_index&lt; Value, value_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the values of a value list.  <a href="structentt_1_1value__list__index_3_01Value_00_01value__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__unique.html">value_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__unique_3_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_unique&lt; value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates values from a value list.  <a href="structentt_1_1value__list__unique_3_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__unique_3_01value__list_3_4_01_4.html">value_list_unique&lt; value_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates values from a value list.  <a href="structentt_1_1value__list__unique_3_01value__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1y__combinator.html">y_combinator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a y-combinator.  <a href="structentt_1_1y__combinator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abdba4f06564fb96e8dfb38c272656d0a" id="r_abdba4f06564fb96e8dfb38c272656d0a"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:abdba4f06564fb96e8dfb38c272656d0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdba4f06564fb96e8dfb38c272656d0a">table</a> = <a class="el" href="classentt_1_1basic__table.html">basic_table</a>&lt;std::vector&lt;Type&gt;...&gt;</td></tr>
<tr class="memdesc:abdba4f06564fb96e8dfb38c272656d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:abdba4f06564fb96e8dfb38c272656d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620d583c0e6d64acf3d394524bb72303" id="r_a620d583c0e6d64acf3d394524bb72303"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> = std::uint32_t</td></tr>
<tr class="memdesc:a620d583c0e6d64acf3d394524bb72303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for type identifiers.  <br /></td></tr>
<tr class="separator:a620d583c0e6d64acf3d394524bb72303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74619fe0ddf5ff5ea9cf98812a3d70ce" id="r_a74619fe0ddf5ff5ea9cf98812a3d70ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74619fe0ddf5ff5ea9cf98812a3d70ce">any</a> = <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;&gt;</td></tr>
<tr class="memdesc:a74619fe0ddf5ff5ea9cf98812a3d70ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a74619fe0ddf5ff5ea9cf98812a3d70ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c166c8989e0afebf8180e6c85683a" id="r_a1a4c166c8989e0afebf8180e6c85683a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4c166c8989e0afebf8180e6c85683a">hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt;char&gt;</td></tr>
<tr class="memdesc:a1a4c166c8989e0afebf8180e6c85683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types.  <br /></td></tr>
<tr class="separator:a1a4c166c8989e0afebf8180e6c85683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577734cb888e132ce8d87efc5c28ec4" id="r_ac577734cb888e132ce8d87efc5c28ec4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac577734cb888e132ce8d87efc5c28ec4">hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt;wchar_t&gt;</td></tr>
<tr class="memdesc:ac577734cb888e132ce8d87efc5c28ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types.  <br /></td></tr>
<tr class="separator:ac577734cb888e132ce8d87efc5c28ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674c50d8037ae08ac4f860e65cbfb137" id="r_a674c50d8037ae08ac4f860e65cbfb137"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a674c50d8037ae08ac4f860e65cbfb137"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a674c50d8037ae08ac4f860e65cbfb137">type_identity_t</a> = typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt;Type&gt;::type</td></tr>
<tr class="memdesc:a674c50d8037ae08ac4f860e65cbfb137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a674c50d8037ae08ac4f860e65cbfb137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bd626da1438d95cf45acea68e7d5af" id="r_ac3bd626da1438d95cf45acea68e7d5af"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename&gt; </td></tr>
<tr class="memitem:ac3bd626da1438d95cf45acea68e7d5af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3bd626da1438d95cf45acea68e7d5af">unpack_as_type</a> = Type</td></tr>
<tr class="memdesc:ac3bd626da1438d95cf45acea68e7d5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack.  <br /></td></tr>
<tr class="separator:ac3bd626da1438d95cf45acea68e7d5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e653af66fcdc9e4abc2a81f362b8963" id="r_a0e653af66fcdc9e4abc2a81f362b8963"><td class="memTemplParams" colspan="2">template&lt;auto Value&gt; </td></tr>
<tr class="memitem:a0e653af66fcdc9e4abc2a81f362b8963"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e653af66fcdc9e4abc2a81f362b8963">integral_constant</a> = std::integral_constant&lt;decltype(Value), Value&gt;</td></tr>
<tr class="memdesc:a0e653af66fcdc9e4abc2a81f362b8963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a static constant.  <br /></td></tr>
<tr class="separator:a0e653af66fcdc9e4abc2a81f362b8963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20502ac2073901175466d05be8a3c20" id="r_ae20502ac2073901175466d05be8a3c20"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> Value&gt; </td></tr>
<tr class="memitem:ae20502ac2073901175466d05be8a3c20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae20502ac2073901175466d05be8a3c20">tag</a> = <a class="el" href="#a0e653af66fcdc9e4abc2a81f362b8963">integral_constant</a>&lt;Value&gt;</td></tr>
<tr class="memdesc:ae20502ac2073901175466d05be8a3c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the creation of named values.  <br /></td></tr>
<tr class="separator:ae20502ac2073901175466d05be8a3c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac8221f536d5ecb512dc433ec7a4fd1" id="r_a9ac8221f536d5ecb512dc433ec7a4fd1"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List&gt; </td></tr>
<tr class="memitem:a9ac8221f536d5ecb512dc433ec7a4fd1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ac8221f536d5ecb512dc433ec7a4fd1">type_list_element_t</a> = typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt;Index, List&gt;::type</td></tr>
<tr class="memdesc:a9ac8221f536d5ecb512dc433ec7a4fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a9ac8221f536d5ecb512dc433ec7a4fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f80f743d8761c2ff8c6f25c8cafece" id="r_a23f80f743d8761c2ff8c6f25c8cafece"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a23f80f743d8761c2ff8c6f25c8cafece"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23f80f743d8761c2ff8c6f25c8cafece">type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td></tr>
<tr class="memdesc:a23f80f743d8761c2ff8c6f25c8cafece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a23f80f743d8761c2ff8c6f25c8cafece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ec7a62f8c682a15e93d1f928fbf8ae" id="r_aa9ec7a62f8c682a15e93d1f928fbf8ae"><td class="memTemplParams" colspan="2">template&lt;typename List&gt; </td></tr>
<tr class="memitem:aa9ec7a62f8c682a15e93d1f928fbf8ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9ec7a62f8c682a15e93d1f928fbf8ae">type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;List&gt;::type</td></tr>
<tr class="memdesc:aa9ec7a62f8c682a15e93d1f928fbf8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:aa9ec7a62f8c682a15e93d1f928fbf8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef0f9bd24a7cefac7835cce5744a6cd" id="r_a4ef0f9bd24a7cefac7835cce5744a6cd"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a4ef0f9bd24a7cefac7835cce5744a6cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ef0f9bd24a7cefac7835cce5744a6cd">type_list_diff_t</a> = typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt;List...&gt;::type</td></tr>
<tr class="memdesc:a4ef0f9bd24a7cefac7835cce5744a6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a4ef0f9bd24a7cefac7835cce5744a6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aaff6276ebe93f2e478c4b07c40902" id="r_a24aaff6276ebe93f2e478c4b07c40902"><td class="memTemplParams" colspan="2">template&lt;typename List, template&lt; typename... &gt; class Op&gt; </td></tr>
<tr class="memitem:a24aaff6276ebe93f2e478c4b07c40902"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a> = typename <a class="el" href="structentt_1_1type__list__transform.html">type_list_transform</a>&lt;List, Op&gt;::type</td></tr>
<tr class="memdesc:a24aaff6276ebe93f2e478c4b07c40902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a24aaff6276ebe93f2e478c4b07c40902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab468f1f4331cb1b664ee21fe4a22acab" id="r_ab468f1f4331cb1b664ee21fe4a22acab"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List&gt; </td></tr>
<tr class="memitem:ab468f1f4331cb1b664ee21fe4a22acab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab468f1f4331cb1b664ee21fe4a22acab">value_list_element_t</a> = typename <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::type</td></tr>
<tr class="memdesc:ab468f1f4331cb1b664ee21fe4a22acab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:ab468f1f4331cb1b664ee21fe4a22acab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9b49e40def274e6187d16435c79602" id="r_a3c9b49e40def274e6187d16435c79602"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a3c9b49e40def274e6187d16435c79602"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c9b49e40def274e6187d16435c79602">value_list_cat_t</a> = typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt;List...&gt;::type</td></tr>
<tr class="memdesc:a3c9b49e40def274e6187d16435c79602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a3c9b49e40def274e6187d16435c79602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac9e0d197ae6d01eb31645245a0773" id="r_a2aac9e0d197ae6d01eb31645245a0773"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a2aac9e0d197ae6d01eb31645245a0773"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2aac9e0d197ae6d01eb31645245a0773">value_list_unique_t</a> = typename <a class="el" href="structentt_1_1value__list__unique.html">value_list_unique</a>&lt;Type&gt;::type</td></tr>
<tr class="memdesc:a2aac9e0d197ae6d01eb31645245a0773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a2aac9e0d197ae6d01eb31645245a0773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1704c849f4643f1063e7ac036117f8" id="r_abb1704c849f4643f1063e7ac036117f8"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:abb1704c849f4643f1063e7ac036117f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb1704c849f4643f1063e7ac036117f8">value_list_diff_t</a> = typename <a class="el" href="structentt_1_1value__list__diff.html">value_list_diff</a>&lt;List...&gt;::type</td></tr>
<tr class="memdesc:abb1704c849f4643f1063e7ac036117f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:abb1704c849f4643f1063e7ac036117f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13168ef82af733bfe584f34f29472d20" id="r_a13168ef82af733bfe584f34f29472d20"><td class="memTemplParams" colspan="2">template&lt;typename To, typename From&gt; </td></tr>
<tr class="memitem:a13168ef82af733bfe584f34f29472d20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13168ef82af733bfe584f34f29472d20">constness_as_t</a> = typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt;To, From&gt;::type</td></tr>
<tr class="memdesc:a13168ef82af733bfe584f34f29472d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the transcription of the constness.  <br /></td></tr>
<tr class="separator:a13168ef82af733bfe584f34f29472d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c5343afb213cf29d3703cdc2c8cbc" id="r_a021c5343afb213cf29d3703cdc2c8cbc"><td class="memTemplParams" colspan="2">template&lt;typename Member&gt; </td></tr>
<tr class="memitem:a021c5343afb213cf29d3703cdc2c8cbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a021c5343afb213cf29d3703cdc2c8cbc">member_class_t</a> = typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt;Member&gt;::type</td></tr>
<tr class="memdesc:a021c5343afb213cf29d3703cdc2c8cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a021c5343afb213cf29d3703cdc2c8cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1665363338d4c3e3a6b4afbec94d0d49" id="r_a1665363338d4c3e3a6b4afbec94d0d49"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename Candidate&gt; </td></tr>
<tr class="memitem:a1665363338d4c3e3a6b4afbec94d0d49"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1665363338d4c3e3a6b4afbec94d0d49">nth_argument_t</a> = typename <a class="el" href="classentt_1_1nth__argument.html">nth_argument</a>&lt;Index, Candidate&gt;::type</td></tr>
<tr class="memdesc:a1665363338d4c3e3a6b4afbec94d0d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a1665363338d4c3e3a6b4afbec94d0d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af720baaca44bb4f3e4d7297777e53a2f" id="r_af720baaca44bb4f3e4d7297777e53a2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af720baaca44bb4f3e4d7297777e53a2f">sparse_set</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt;&gt;</td></tr>
<tr class="memdesc:af720baaca44bb4f3e4d7297777e53a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:af720baaca44bb4f3e4d7297777e53a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8fd99fc1ff2432dcb0f6b017a9c60e" id="r_aff8fd99fc1ff2432dcb0f6b017a9c60e"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:aff8fd99fc1ff2432dcb0f6b017a9c60e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff8fd99fc1ff2432dcb0f6b017a9c60e">storage</a> = <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt;Type&gt;</td></tr>
<tr class="memdesc:aff8fd99fc1ff2432dcb0f6b017a9c60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:aff8fd99fc1ff2432dcb0f6b017a9c60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae235426965a236ddde9fa92979f73d5d" id="r_ae235426965a236ddde9fa92979f73d5d"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:ae235426965a236ddde9fa92979f73d5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae235426965a236ddde9fa92979f73d5d">sigh_mixin</a> = <a class="el" href="classentt_1_1basic__sigh__mixin.html">basic_sigh_mixin</a>&lt;Type, <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;typename Type::entity_type, typename Type::base_type::allocator_type&gt;&gt;</td></tr>
<tr class="memdesc:ae235426965a236ddde9fa92979f73d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ae235426965a236ddde9fa92979f73d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9d8ddc2e43b7cda372aa52cbcc2725" id="r_a7d9d8ddc2e43b7cda372aa52cbcc2725"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a7d9d8ddc2e43b7cda372aa52cbcc2725"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d9d8ddc2e43b7cda372aa52cbcc2725">reactive_mixin</a> = <a class="el" href="classentt_1_1basic__reactive__mixin.html">basic_reactive_mixin</a>&lt;Type, <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;typename Type::entity_type, typename Type::base_type::allocator_type&gt;&gt;</td></tr>
<tr class="memdesc:a7d9d8ddc2e43b7cda372aa52cbcc2725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a7d9d8ddc2e43b7cda372aa52cbcc2725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c1f492841aeafa5e75422af3f0cdc4" id="r_ab8c1f492841aeafa5e75422af3f0cdc4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;&gt;</td></tr>
<tr class="memdesc:ab8c1f492841aeafa5e75422af3f0cdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ab8c1f492841aeafa5e75422af3f0cdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20330b209394a912be898c964f228327" id="r_a20330b209394a912be898c964f228327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20330b209394a912be898c964f228327">organizer</a> = <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td></tr>
<tr class="memdesc:a20330b209394a912be898c964f228327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a20330b209394a912be898c964f228327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4709e4ff444e7d9b73f97d9e471bf8af" id="r_a4709e4ff444e7d9b73f97d9e471bf8af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4709e4ff444e7d9b73f97d9e471bf8af">handle</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td></tr>
<tr class="memdesc:a4709e4ff444e7d9b73f97d9e471bf8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a4709e4ff444e7d9b73f97d9e471bf8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8389b9073df462feead9ce84ceeddb" id="r_aed8389b9073df462feead9ce84ceeddb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8389b9073df462feead9ce84ceeddb">const_handle</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td></tr>
<tr class="memdesc:aed8389b9073df462feead9ce84ceeddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:aed8389b9073df462feead9ce84ceeddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4731e2abbad1637d6fd851cf4039f6" id="r_a6f4731e2abbad1637d6fd851cf4039f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6f4731e2abbad1637d6fd851cf4039f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f4731e2abbad1637d6fd851cf4039f6">handle_view</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>, Args...&gt;</td></tr>
<tr class="memdesc:a6f4731e2abbad1637d6fd851cf4039f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a6f4731e2abbad1637d6fd851cf4039f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c301e0976746f3f72b960f1c9c4675" id="r_a06c301e0976746f3f72b960f1c9c4675"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a06c301e0976746f3f72b960f1c9c4675"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06c301e0976746f3f72b960f1c9c4675">const_handle_view</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>, Args...&gt;</td></tr>
<tr class="memdesc:a06c301e0976746f3f72b960f1c9c4675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a06c301e0976746f3f72b960f1c9c4675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81f1e05f8be1263f14284164387c180" id="r_ae81f1e05f8be1263f14284164387c180"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae81f1e05f8be1263f14284164387c180">snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td></tr>
<tr class="memdesc:ae81f1e05f8be1263f14284164387c180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ae81f1e05f8be1263f14284164387c180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcc892243a02aafd27f353bd810fca6" id="r_affcc892243a02aafd27f353bd810fca6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcc892243a02aafd27f353bd810fca6">snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td></tr>
<tr class="memdesc:affcc892243a02aafd27f353bd810fca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:affcc892243a02aafd27f353bd810fca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae827dd63b5553f701ae049a1cf95ef0c" id="r_ae827dd63b5553f701ae049a1cf95ef0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae827dd63b5553f701ae049a1cf95ef0c">continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td></tr>
<tr class="memdesc:ae827dd63b5553f701ae049a1cf95ef0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ae827dd63b5553f701ae049a1cf95ef0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7874d535e3193cbc008ef5c7f02829d" id="r_ae7874d535e3193cbc008ef5c7f02829d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7874d535e3193cbc008ef5c7f02829d">runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt;<a class="el" href="#af720baaca44bb4f3e4d7297777e53a2f">sparse_set</a>&gt;</td></tr>
<tr class="memdesc:ae7874d535e3193cbc008ef5c7f02829d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ae7874d535e3193cbc008ef5c7f02829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ffdaf3a0c8ebdbb2665f9ec1d63f83" id="r_ac3ffdaf3a0c8ebdbb2665f9ec1d63f83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3ffdaf3a0c8ebdbb2665f9ec1d63f83">const_runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt;const <a class="el" href="#af720baaca44bb4f3e4d7297777e53a2f">sparse_set</a>&gt;</td></tr>
<tr class="memdesc:ac3ffdaf3a0c8ebdbb2665f9ec1d63f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ac3ffdaf3a0c8ebdbb2665f9ec1d63f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12841fb02f9eaa12097dbb36251b84dd" id="r_a12841fb02f9eaa12097dbb36251b84dd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a12841fb02f9eaa12097dbb36251b84dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12841fb02f9eaa12097dbb36251b84dd">storage_type_t</a> = typename <a class="el" href="structentt_1_1storage__type.html">storage_type</a>&lt;Args...&gt;::type</td></tr>
<tr class="memdesc:a12841fb02f9eaa12097dbb36251b84dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a12841fb02f9eaa12097dbb36251b84dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e07285e81bdf526b09a38a9618eb13" id="r_ab7e07285e81bdf526b09a38a9618eb13"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab7e07285e81bdf526b09a38a9618eb13"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7e07285e81bdf526b09a38a9618eb13">storage_for_t</a> = typename <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&lt;Args...&gt;::type</td></tr>
<tr class="memdesc:ab7e07285e81bdf526b09a38a9618eb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:ab7e07285e81bdf526b09a38a9618eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f86766cf81509c46f7009f90513d837" id="r_a3f86766cf81509c46f7009f90513d837"><td class="memTemplParams" colspan="2">template&lt;typename Get, typename Exclude = exclude_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:a3f86766cf81509c46f7009f90513d837"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f86766cf81509c46f7009f90513d837">view</a> = <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt;<a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;&gt;</td></tr>
<tr class="memdesc:a3f86766cf81509c46f7009f90513d837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a3f86766cf81509c46f7009f90513d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e718d299437d564f6c3891c4c230f06" id="r_a7e718d299437d564f6c3891c4c230f06"><td class="memTemplParams" colspan="2">template&lt;typename Owned, typename Get = get_t&lt;&gt;, typename Exclude = exclude_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:a7e718d299437d564f6c3891c4c230f06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e718d299437d564f6c3891c4c230f06">group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;<a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Owned, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;&gt;</td></tr>
<tr class="memdesc:a7e718d299437d564f6c3891c4c230f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a7e718d299437d564f6c3891c4c230f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a376b45d5e5ea92f89da92f531975b" id="r_a74a376b45d5e5ea92f89da92f531975b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a376b45d5e5ea92f89da92f531975b">flow</a> = <a class="el" href="classentt_1_1basic__flow.html">basic_flow</a>&lt;&gt;</td></tr>
<tr class="memdesc:a74a376b45d5e5ea92f89da92f531975b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a74a376b45d5e5ea92f89da92f531975b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885dfa7d8e1307ff909f99182a64134" id="r_a7885dfa7d8e1307ff909f99182a64134"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename It&gt; </td></tr>
<tr class="memitem:a7885dfa7d8e1307ff909f99182a64134"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7885dfa7d8e1307ff909f99182a64134">meta_range</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::meta_range_iterator&lt;Type, It&gt;&gt;</td></tr>
<tr class="memdesc:a7885dfa7d8e1307ff909f99182a64134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable range to use to iterate all types of meta objects.  <br /></td></tr>
<tr class="separator:a7885dfa7d8e1307ff909f99182a64134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e96dc705319d2fc6ded344292004f" id="r_a396e96dc705319d2fc6ded344292004f"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Candidate&gt; </td></tr>
<tr class="memitem:a396e96dc705319d2fc6ded344292004f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a396e96dc705319d2fc6ded344292004f">meta_function_helper_t</a> = typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt;Type, Candidate&gt;::type</td></tr>
<tr class="memdesc:a396e96dc705319d2fc6ded344292004f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a396e96dc705319d2fc6ded344292004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d2fe9024bafa328c5f4e4adbc96298" id="r_ab6d2fe9024bafa328c5f4e4adbc96298"><td class="memTemplParams" colspan="2">template&lt;typename Concept&gt; </td></tr>
<tr class="memitem:ab6d2fe9024bafa328c5f4e4adbc96298"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6d2fe9024bafa328c5f4e4adbc96298">poly</a> = <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt;Concept&gt;</td></tr>
<tr class="memdesc:ab6d2fe9024bafa328c5f4e4adbc96298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:ab6d2fe9024bafa328c5f4e4adbc96298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4634a5b738455e0b6d35bb5444dbf4" id="r_afb4634a5b738455e0b6d35bb5444dbf4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb4634a5b738455e0b6d35bb5444dbf4">scheduler</a> = <a class="el" href="classentt_1_1basic__scheduler.html">basic_scheduler</a>&lt;&gt;</td></tr>
<tr class="memdesc:afb4634a5b738455e0b6d35bb5444dbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:afb4634a5b738455e0b6d35bb5444dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a861217be8dba074e93e11eaf9bfe0c" id="r_a0a861217be8dba074e93e11eaf9bfe0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a861217be8dba074e93e11eaf9bfe0c">dispatcher</a> = <a class="el" href="classentt_1_1basic__dispatcher.html">basic_dispatcher</a>&lt;&gt;</td></tr>
<tr class="memdesc:a0a861217be8dba074e93e11eaf9bfe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <br /></td></tr>
<tr class="separator:a0a861217be8dba074e93e11eaf9bfe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:add777bc22ff30abfbf52abd37d4e1549" id="r_add777bc22ff30abfbf52abd37d4e1549"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add777bc22ff30abfbf52abd37d4e1549">any_policy</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="#add777bc22ff30abfbf52abd37d4e1549aa2e4822a98337283e39f7b60acf85ec9">empty</a>
, <a class="el" href="#add777bc22ff30abfbf52abd37d4e1549ab72f3bd391ba731a35708bfd8cd8a68f">dynamic</a>
, <a class="el" href="#add777bc22ff30abfbf52abd37d4e1549a605abe26d014c72e3df9deb267e73756">embedded</a>
, <a class="el" href="#add777bc22ff30abfbf52abd37d4e1549a18389a4a9ad5795744699cff0ba66c15">ref</a>
, <br />
&#160;&#160;<a class="el" href="#add777bc22ff30abfbf52abd37d4e1549a1e67f2ff0161fbaf51eccefa9abc6ad2">cref</a>
<br />
 }</td></tr>
<tr class="memdesc:add777bc22ff30abfbf52abd37d4e1549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible modes of an any object.  <a href="#add777bc22ff30abfbf52abd37d4e1549">More...</a><br /></td></tr>
<tr class="separator:add777bc22ff30abfbf52abd37d4e1549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b54e231d069e8a231e14b223388808a" id="r_a0b54e231d069e8a231e14b223388808a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b54e231d069e8a231e14b223388808a">entity</a> : id_type </td></tr>
<tr class="memdesc:a0b54e231d069e8a231e14b223388808a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default entity identifier.  <a href="#a0b54e231d069e8a231e14b223388808a">More...</a><br /></td></tr>
<tr class="separator:a0b54e231d069e8a231e14b223388808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d0fa77fae26e7c01793990996c581" id="r_abc4d0fa77fae26e7c01793990996c581"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> : std::uint8_t { <a class="el" href="#abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708">swap_and_pop</a> = 0u
, <a class="el" href="#abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28">in_place</a> = 1u
, <a class="el" href="#abc4d0fa77fae26e7c01793990996c581a62044f8c7b1568e4536403704282322b">swap_only</a> = 2u
, <a class="el" href="#abc4d0fa77fae26e7c01793990996c581ad415f0e30c471dfdd9bc4f827329ef48">unspecified</a> = swap_and_pop
 }</td></tr>
<tr class="memdesc:abc4d0fa77fae26e7c01793990996c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage deletion policy.  <a href="#abc4d0fa77fae26e7c01793990996c581">More...</a><br /></td></tr>
<tr class="separator:abc4d0fa77fae26e7c01793990996c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add777bc22ff30abfbf52abd37d4e1549" id="r_add777bc22ff30abfbf52abd37d4e1549"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add777bc22ff30abfbf52abd37d4e1549">any_policy</a> </td></tr>
<tr class="memdesc:add777bc22ff30abfbf52abd37d4e1549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible modes of an any object.  <a href="#add777bc22ff30abfbf52abd37d4e1549">More...</a><br /></td></tr>
<tr class="separator:add777bc22ff30abfbf52abd37d4e1549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4ce71953bc9fb5283641465fb40025dc" id="r_a4ce71953bc9fb5283641465fb40025dc"><td class="memTemplParams" colspan="2">template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a4ce71953bc9fb5283641465fb40025dc"><td class="memTemplItemLeft" align="right" valign="top">std::remove_const_t&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ce71953bc9fb5283641465fb40025dc">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a4ce71953bc9fb5283641465fb40025dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <br /></td></tr>
<tr class="separator:a4ce71953bc9fb5283641465fb40025dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12027badfdd7739493d9a38a6c3cc913" id="r_a12027badfdd7739493d9a38a6c3cc913"><td class="memTemplParams" colspan="2">template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a12027badfdd7739493d9a38a6c3cc913"><td class="memTemplItemLeft" align="right" valign="top">std::remove_const_t&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12027badfdd7739493d9a38a6c3cc913">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a12027badfdd7739493d9a38a6c3cc913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.     <br /></td></tr>
<tr class="separator:a12027badfdd7739493d9a38a6c3cc913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ca839d106a61776fd7f4f1041ae9ee" id="r_a12ca839d106a61776fd7f4f1041ae9ee"><td class="memTemplParams" colspan="2">template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a12ca839d106a61776fd7f4f1041ae9ee"><td class="memTemplItemLeft" align="right" valign="top">std::remove_const_t&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12ca839d106a61776fd7f4f1041ae9ee">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;data) noexcept</td></tr>
<tr class="memdesc:a12ca839d106a61776fd7f4f1041ae9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.     <br /></td></tr>
<tr class="separator:a12ca839d106a61776fd7f4f1041ae9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf666ed024f5542f987b8b5a658f64" id="r_aaabf666ed024f5542f987b8b5a658f64"><td class="memTemplParams" colspan="2">template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:aaabf666ed024f5542f987b8b5a658f64"><td class="memTemplItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaabf666ed024f5542f987b8b5a658f64">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data) noexcept</td></tr>
<tr class="memdesc:aaabf666ed024f5542f987b8b5a658f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.     <br /></td></tr>
<tr class="separator:aaabf666ed024f5542f987b8b5a658f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b7dd1eaac2e05f42febf94331e1ac0" id="r_ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="memTemplParams" colspan="2">template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0b7dd1eaac2e05f42febf94331e1ac0">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data) noexcept</td></tr>
<tr class="memdesc:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.     <br /></td></tr>
<tr class="separator:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb86dc3145589485c094960a089eb953" id="r_adb86dc3145589485c094960a089eb953"><td class="memTemplParams" colspan="2">template&lt;typename Type, std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </td></tr>
<tr class="memitem:adb86dc3145589485c094960a089eb953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb86dc3145589485c094960a089eb953">make_any</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:adb86dc3145589485c094960a089eb953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a wrapper from a given type, passing it all arguments.  <br /></td></tr>
<tr class="separator:adb86dc3145589485c094960a089eb953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02fa96c663a6706416e47a3a6658328" id="r_af02fa96c663a6706416e47a3a6658328"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type&gt; </td></tr>
<tr class="memitem:af02fa96c663a6706416e47a3a6658328"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af02fa96c663a6706416e47a3a6658328">forward_as_any</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:af02fa96c663a6706416e47a3a6658328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <br /></td></tr>
<tr class="separator:af02fa96c663a6706416e47a3a6658328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab136c473d8c862b183cec9d4a13915" id="r_afab136c473d8c862b183cec9d4a13915"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:afab136c473d8c862b183cec9d4a13915"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afab136c473d8c862b183cec9d4a13915">popcount</a> (const Type value) noexcept</td></tr>
<tr class="memdesc:afab136c473d8c862b183cec9d4a13915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in a value (waiting for C++20 and <code>std::popcount</code>).  <br /></td></tr>
<tr class="separator:afab136c473d8c862b183cec9d4a13915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0d94baafb4291b7dc5a49ba6f1b0e5" id="r_a1c0d94baafb4291b7dc5a49ba6f1b0e5"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a1c0d94baafb4291b7dc5a49ba6f1b0e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c0d94baafb4291b7dc5a49ba6f1b0e5">has_single_bit</a> (const Type value) noexcept</td></tr>
<tr class="memdesc:a1c0d94baafb4291b7dc5a49ba6f1b0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a value is a power of two or not (waiting for C++20 and <code>std::has_single_bit</code>).  <br /></td></tr>
<tr class="separator:a1c0d94baafb4291b7dc5a49ba6f1b0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6fb41a1c8c0c5968bfca369e51a73e" id="r_a8f6fb41a1c8c0c5968bfca369e51a73e"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a8f6fb41a1c8c0c5968bfca369e51a73e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f6fb41a1c8c0c5968bfca369e51a73e">next_power_of_two</a> (const Type value) noexcept</td></tr>
<tr class="memdesc:a8f6fb41a1c8c0c5968bfca369e51a73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest power of two greater than or equal to a value (waiting for C++20 and <code>std::bit_ceil</code>).  <br /></td></tr>
<tr class="separator:a8f6fb41a1c8c0c5968bfca369e51a73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae98eeee0b0cb3e94d97d08a74a06f0" id="r_a1ae98eeee0b0cb3e94d97d08a74a06f0"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a1ae98eeee0b0cb3e94d97d08a74a06f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ae98eeee0b0cb3e94d97d08a74a06f0">fast_mod</a> (const Type value, const std::size_t mod) noexcept</td></tr>
<tr class="memdesc:a1ae98eeee0b0cb3e94d97d08a74a06f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast module utility function (powers of two only).  <br /></td></tr>
<tr class="separator:a1ae98eeee0b0cb3e94d97d08a74a06f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93ac21ff904a1ba357caf8ea40cd7f" id="r_afd93ac21ff904a1ba357caf8ea40cd7f"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Other&gt; </td></tr>
<tr class="memitem:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd93ac21ff904a1ba357caf8ea40cd7f">compressed_pair</a> (Type &amp;&amp;, Other &amp;&amp;) -&gt; compressed_pair&lt; std::decay_t&lt; Type &gt;, std::decay_t&lt; Other &gt; &gt;</td></tr>
<tr class="memdesc:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e05563b8d3e3b61cf9b06e9e0904cc7" id="r_a2e05563b8d3e3b61cf9b06e9e0904cc7"><td class="memTemplParams" colspan="2">template&lt;typename First, typename Second&gt; </td></tr>
<tr class="memitem:a2e05563b8d3e3b61cf9b06e9e0904cc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e05563b8d3e3b61cf9b06e9e0904cc7">swap</a> (<a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;lhs, <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2e05563b8d3e3b61cf9b06e9e0904cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two compressed pair objects.  <br /></td></tr>
<tr class="separator:a2e05563b8d3e3b61cf9b06e9e0904cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eb2a322b4bf420d74580c0dd71d4d9" id="r_a14eb2a322b4bf420d74580c0dd71d4d9"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:a14eb2a322b4bf420d74580c0dd71d4d9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14eb2a322b4bf420d74580c0dd71d4d9">basic_hashed_string</a> (const Char *str, std::size_t len) -&gt; basic_hashed_string&lt; Char &gt;</td></tr>
<tr class="memdesc:a14eb2a322b4bf420d74580c0dd71d4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:a14eb2a322b4bf420d74580c0dd71d4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392" id="r_aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplParams" colspan="2">template&lt;typename Char, std::size_t N&gt; </td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa97361ef962166a4fc51a582d7c6392">basic_hashed_string</a> (const Char(&amp;str)[N]) -&gt; basic_hashed_string&lt; Char &gt;</td></tr>
<tr class="memdesc:aaa97361ef962166a4fc51a582d7c6392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:aaa97361ef962166a4fc51a582d7c6392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c61951b721a1e3612cf536bd707501" id="r_af7c61951b721a1e3612cf536bd707501"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:af7c61951b721a1e3612cf536bd707501"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7c61951b721a1e3612cf536bd707501">operator==</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af7c61951b721a1e3612cf536bd707501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <br /></td></tr>
<tr class="separator:af7c61951b721a1e3612cf536bd707501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9accc71a383509ada028f7fa2b767bf" id="r_ad9accc71a383509ada028f7fa2b767bf"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:ad9accc71a383509ada028f7fa2b767bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9accc71a383509ada028f7fa2b767bf">operator!=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad9accc71a383509ada028f7fa2b767bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <br /></td></tr>
<tr class="separator:ad9accc71a383509ada028f7fa2b767bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88e297d57dd5547afcde8dd291c4b8f" id="r_aa88e297d57dd5547afcde8dd291c4b8f"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:aa88e297d57dd5547afcde8dd291c4b8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa88e297d57dd5547afcde8dd291c4b8f">operator&lt;</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa88e297d57dd5547afcde8dd291c4b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <br /></td></tr>
<tr class="separator:aa88e297d57dd5547afcde8dd291c4b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c763e890bb00479a6a6aeae3b2a75f0" id="r_a8c763e890bb00479a6a6aeae3b2a75f0"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c763e890bb00479a6a6aeae3b2a75f0">operator&lt;=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <br /></td></tr>
<tr class="separator:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8131af000055ceab85646c14f234ad" id="r_aec8131af000055ceab85646c14f234ad"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:aec8131af000055ceab85646c14f234ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec8131af000055ceab85646c14f234ad">operator&gt;</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aec8131af000055ceab85646c14f234ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <br /></td></tr>
<tr class="separator:aec8131af000055ceab85646c14f234ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb88dfb4278df554e7ffec5361ece4" id="r_adadb88dfb4278df554e7ffec5361ece4"><td class="memTemplParams" colspan="2">template&lt;typename Char&gt; </td></tr>
<tr class="memitem:adadb88dfb4278df554e7ffec5361ece4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adadb88dfb4278df554e7ffec5361ece4">operator&gt;=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:adadb88dfb4278df554e7ffec5361ece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <br /></td></tr>
<tr class="separator:adadb88dfb4278df554e7ffec5361ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5ebc5e9d0e87c18a22a72d2261bdf5" id="r_a6d5ebc5e9d0e87c18a22a72d2261bdf5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a1a4c166c8989e0afebf8180e6c85683a">hashed_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d5ebc5e9d0e87c18a22a72d2261bdf5">operator&quot;&quot;_hs</a> (const char *str, std::size_t) noexcept</td></tr>
<tr class="memdesc:a6d5ebc5e9d0e87c18a22a72d2261bdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed strings.  <br /></td></tr>
<tr class="separator:a6d5ebc5e9d0e87c18a22a72d2261bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa5b29e7184fb8fe184417411792290" id="r_a6fa5b29e7184fb8fe184417411792290"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ac577734cb888e132ce8d87efc5c28ec4">hashed_wstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa5b29e7184fb8fe184417411792290">operator&quot;&quot;_hws</a> (const wchar_t *str, std::size_t) noexcept</td></tr>
<tr class="memdesc:a6fa5b29e7184fb8fe184417411792290"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed wstrings.  <br /></td></tr>
<tr class="separator:a6fa5b29e7184fb8fe184417411792290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4423ccae6f6edef721acf6624b8cec41" id="r_a4423ccae6f6edef721acf6624b8cec41"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a4423ccae6f6edef721acf6624b8cec41"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4423ccae6f6edef721acf6624b8cec41">operator==</a> (const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;lhs, const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4423ccae6f6edef721acf6624b8cec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <br /></td></tr>
<tr class="separator:a4423ccae6f6edef721acf6624b8cec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ee8e2a3f32a371b44e579ef0d0f25" id="r_a883ee8e2a3f32a371b44e579ef0d0f25"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a883ee8e2a3f32a371b44e579ef0d0f25">operator!=</a> (const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;lhs, const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <br /></td></tr>
<tr class="separator:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ecb90b45a53e3272d761c237a0d850" id="r_af0ecb90b45a53e3272d761c237a0d850"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:af0ecb90b45a53e3272d761c237a0d850"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0ecb90b45a53e3272d761c237a0d850">to_address</a> (Type &amp;&amp;ptr) noexcept</td></tr>
<tr class="memdesc:af0ecb90b45a53e3272d761c237a0d850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps fancy pointers, does nothing otherwise (waiting for C++20).  <br /></td></tr>
<tr class="separator:af0ecb90b45a53e3272d761c237a0d850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae934980252d1f2ce8f2473c8d74347df" id="r_ae934980252d1f2ce8f2473c8d74347df"><td class="memTemplParams" colspan="2">template&lt;typename Allocator&gt; </td></tr>
<tr class="memitem:ae934980252d1f2ce8f2473c8d74347df"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae934980252d1f2ce8f2473c8d74347df">propagate_on_container_copy_assignment</a> (Allocator &amp;lhs, Allocator &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae934980252d1f2ce8f2473c8d74347df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <br /></td></tr>
<tr class="separator:ae934980252d1f2ce8f2473c8d74347df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cd263b358a2d495d4f4ee27d4537d7" id="r_a46cd263b358a2d495d4f4ee27d4537d7"><td class="memTemplParams" colspan="2">template&lt;typename Allocator&gt; </td></tr>
<tr class="memitem:a46cd263b358a2d495d4f4ee27d4537d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46cd263b358a2d495d4f4ee27d4537d7">propagate_on_container_move_assignment</a> (Allocator &amp;lhs, Allocator &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a46cd263b358a2d495d4f4ee27d4537d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <br /></td></tr>
<tr class="separator:a46cd263b358a2d495d4f4ee27d4537d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd7ed3d3f11933cd542d8f4646cd695" id="r_a0dd7ed3d3f11933cd542d8f4646cd695"><td class="memTemplParams" colspan="2">template&lt;typename Allocator&gt; </td></tr>
<tr class="memitem:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0dd7ed3d3f11933cd542d8f4646cd695">propagate_on_container_swap</a> (Allocator &amp;lhs, Allocator &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <br /></td></tr>
<tr class="separator:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3729f1b7699d013f982b2de2ec781f9" id="r_ae3729f1b7699d013f982b2de2ec781f9"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Allocator, typename... Args&gt; </td></tr>
<tr class="memitem:ae3729f1b7699d013f982b2de2ec781f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3729f1b7699d013f982b2de2ec781f9">allocate_unique</a> (Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae3729f1b7699d013f982b2de2ec781f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows <code>std::unique_ptr</code> to use allocators (waiting for C++20).  <br /></td></tr>
<tr class="separator:ae3729f1b7699d013f982b2de2ec781f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac447ddab9d528647a79fd9aca429faed" id="r_ac447ddab9d528647a79fd9aca429faed"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Allocator, typename... Args&gt; </td></tr>
<tr class="memitem:ac447ddab9d528647a79fd9aca429faed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac447ddab9d528647a79fd9aca429faed">uses_allocator_construction_args</a> (const Allocator &amp;allocator, Args &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:ac447ddab9d528647a79fd9aca429faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses-allocator construction utility (waiting for C++20).  <br /></td></tr>
<tr class="separator:ac447ddab9d528647a79fd9aca429faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4d0c58f9c4cc6f5513c39c530b9b7" id="r_a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Allocator, typename... Args&gt; </td></tr>
<tr class="memitem:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12e4d0c58f9c4cc6f5513c39c530b9b7">make_obj_using_allocator</a> (const Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses-allocator construction utility (waiting for C++20).  <br /></td></tr>
<tr class="separator:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f946567d220e7c8814636333d0cbe0" id="r_a81f946567d220e7c8814636333d0cbe0"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Allocator, typename... Args&gt; </td></tr>
<tr class="memitem:a81f946567d220e7c8814636333d0cbe0"><td class="memTemplItemLeft" align="right" valign="top">constexpr Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81f946567d220e7c8814636333d0cbe0">uninitialized_construct_using_allocator</a> (Type *value, const Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a81f946567d220e7c8814636333d0cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses-allocator construction utility (waiting for C++20).  <br /></td></tr>
<tr class="separator:a81f946567d220e7c8814636333d0cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2665e41871f7493f674c8dbba0a593" id="r_abf2665e41871f7493f674c8dbba0a593"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:abf2665e41871f7493f674c8dbba0a593"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf2665e41871f7493f674c8dbba0a593">unwrap_tuple</a> (Type &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:abf2665e41871f7493f674c8dbba0a593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to unwrap tuples of a single element.  <br /></td></tr>
<tr class="separator:abf2665e41871f7493f674c8dbba0a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0662ddd2021dbf1513b7d0b40c50b9b2" id="r_a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0662ddd2021dbf1513b7d0b40c50b9b2">forward_apply</a> (Func) -&gt; forward_apply&lt; std::remove_reference_t&lt; std::remove_cv_t&lt; Func &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcf4803e990dfe0867025bf76de501c" id="r_a2dcf4803e990dfe0867025bf76de501c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dcf4803e990dfe0867025bf76de501c">operator==</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2dcf4803e990dfe0867025bf76de501c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <br /></td></tr>
<tr class="separator:a2dcf4803e990dfe0867025bf76de501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4410448e22ae52de3bcbf262be9030" id="r_afe4410448e22ae52de3bcbf262be9030"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe4410448e22ae52de3bcbf262be9030">operator!=</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:afe4410448e22ae52de3bcbf262be9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <br /></td></tr>
<tr class="separator:afe4410448e22ae52de3bcbf262be9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6216409945594d3a50e9b8d3ad72f7" id="r_a5f6216409945594d3a50e9b8d3ad72f7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f6216409945594d3a50e9b8d3ad72f7">operator&lt;</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5f6216409945594d3a50e9b8d3ad72f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <br /></td></tr>
<tr class="separator:a5f6216409945594d3a50e9b8d3ad72f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce5a8a6786a787daa1a656f221158cf" id="r_acce5a8a6786a787daa1a656f221158cf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acce5a8a6786a787daa1a656f221158cf">operator&lt;=</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acce5a8a6786a787daa1a656f221158cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <br /></td></tr>
<tr class="separator:acce5a8a6786a787daa1a656f221158cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8ef328173f0b43d96f8d042d7f444" id="r_abad8ef328173f0b43d96f8d042d7f444"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abad8ef328173f0b43d96f8d042d7f444">operator&gt;</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abad8ef328173f0b43d96f8d042d7f444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <br /></td></tr>
<tr class="separator:abad8ef328173f0b43d96f8d042d7f444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502743d6a5b36ceff050779d93b444ca" id="r_a502743d6a5b36ceff050779d93b444ca"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a502743d6a5b36ceff050779d93b444ca">operator&gt;=</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a502743d6a5b36ceff050779d93b444ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <br /></td></tr>
<tr class="separator:a502743d6a5b36ceff050779d93b444ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9682d476edbbe4434680363f9c0eb3" id="r_adb9682d476edbbe4434680363f9c0eb3"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:adb9682d476edbbe4434680363f9c0eb3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb9682d476edbbe4434680363f9c0eb3">type_id</a> () noexcept</td></tr>
<tr class="memdesc:adb9682d476edbbe4434680363f9c0eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object associated to a given type.  <br /></td></tr>
<tr class="separator:adb9682d476edbbe4434680363f9c0eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17387091b8374f89bfd73b2630768b53" id="r_a17387091b8374f89bfd73b2630768b53"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a17387091b8374f89bfd73b2630768b53"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17387091b8374f89bfd73b2630768b53">type_id</a> (Type &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a17387091b8374f89bfd73b2630768b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object associated to a given type.     <br /></td></tr>
<tr class="separator:a17387091b8374f89bfd73b2630768b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36ceb26049f62c07817a385e35395f6" id="r_ab36ceb26049f62c07817a385e35395f6"><td class="memTemplParams" colspan="2">template&lt;typename... Type, typename... Other&gt; </td></tr>
<tr class="memitem:ab36ceb26049f62c07817a385e35395f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab36ceb26049f62c07817a385e35395f6">operator+</a> (<a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:ab36ceb26049f62c07817a385e35395f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <br /></td></tr>
<tr class="separator:ab36ceb26049f62c07817a385e35395f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64074f983c827563bdd5cf7d5dde" id="r_a722a64074f983c827563bdd5cf7d5dde"><td class="memTemplParams" colspan="2">template&lt;auto... Value, auto... Other&gt; </td></tr>
<tr class="memitem:a722a64074f983c827563bdd5cf7d5dde"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a722a64074f983c827563bdd5cf7d5dde">operator+</a> (<a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;, <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:a722a64074f983c827563bdd5cf7d5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <br /></td></tr>
<tr class="separator:a722a64074f983c827563bdd5cf7d5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5131df9ce458a6884c43595f501f916" id="r_ac5131df9ce458a6884c43595f501f916"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Class&gt; </td></tr>
<tr class="memitem:ac5131df9ce458a6884c43595f501f916"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5131df9ce458a6884c43595f501f916">overload</a> (Type Class::*member) noexcept</td></tr>
<tr class="memdesc:ac5131df9ce458a6884c43595f501f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded members of a class.  <br /></td></tr>
<tr class="separator:ac5131df9ce458a6884c43595f501f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f6d6d3ea49bd36f7e8d2f002ec1d1" id="r_a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a267f6d6d3ea49bd36f7e8d2f002ec1d1">overload</a> (Func *func) noexcept</td></tr>
<tr class="memdesc:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded functions.  <br /></td></tr>
<tr class="separator:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb" id="r_a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplParams" colspan="2">template&lt;typename... Func&gt; </td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26eb67ac302229374c5fb623d529f5eb">overloaded</a> (Func...) -&gt; overloaded&lt; Func... &gt;</td></tr>
<tr class="memdesc:a26eb67ac302229374c5fb623d529f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:a26eb67ac302229374c5fb623d529f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e252dbd8c8ebd486a3d84fbf8c2602" id="r_ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2e252dbd8c8ebd486a3d84fbf8c2602">to_integral</a> (const Entity value) noexcept</td></tr>
<tr class="memdesc:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an entity to its underlying type.  <br /></td></tr>
<tr class="separator:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202b4027d32db124efffdf1f2f8c5a2" id="r_a1202b4027d32db124efffdf1f2f8c5a2"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:a1202b4027d32db124efffdf1f2f8c5a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1202b4027d32db124efffdf1f2f8c5a2">to_entity</a> (const Entity value) noexcept</td></tr>
<tr class="memdesc:a1202b4027d32db124efffdf1f2f8c5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity part once converted to the underlying type.  <br /></td></tr>
<tr class="separator:a1202b4027d32db124efffdf1f2f8c5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d8995ec3448ce5151309ef2281d33" id="r_a4b7d8995ec3448ce5151309ef2281d33"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:a4b7d8995ec3448ce5151309ef2281d33"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::version_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b7d8995ec3448ce5151309ef2281d33">to_version</a> (const Entity value) noexcept</td></tr>
<tr class="memdesc:a4b7d8995ec3448ce5151309ef2281d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version part once converted to the underlying type.  <br /></td></tr>
<tr class="separator:a4b7d8995ec3448ce5151309ef2281d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d2331ec59eb76f0304e675cfd645db" id="r_a60d2331ec59eb76f0304e675cfd645db"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:a60d2331ec59eb76f0304e675cfd645db"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60d2331ec59eb76f0304e675cfd645db">operator==</a> (const Entity lhs, const <a class="el" href="structentt_1_1null__t.html">null_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:a60d2331ec59eb76f0304e675cfd645db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an identifier of any type.  <br /></td></tr>
<tr class="separator:a60d2331ec59eb76f0304e675cfd645db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abdd7e1b2d1e98662354d5b8f691e91" id="r_a9abdd7e1b2d1e98662354d5b8f691e91"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:a9abdd7e1b2d1e98662354d5b8f691e91"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9abdd7e1b2d1e98662354d5b8f691e91">operator!=</a> (const Entity lhs, const <a class="el" href="structentt_1_1null__t.html">null_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9abdd7e1b2d1e98662354d5b8f691e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an identifier of any type.  <br /></td></tr>
<tr class="separator:a9abdd7e1b2d1e98662354d5b8f691e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9332718aa52e1ebd2c22c825eec7075c" id="r_a9332718aa52e1ebd2c22c825eec7075c"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:a9332718aa52e1ebd2c22c825eec7075c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9332718aa52e1ebd2c22c825eec7075c">operator==</a> (const Entity lhs, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9332718aa52e1ebd2c22c825eec7075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an identifier of any type.  <br /></td></tr>
<tr class="separator:a9332718aa52e1ebd2c22c825eec7075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010897ed603a4eb066ea9d151a5f6cc" id="r_a5010897ed603a4eb066ea9d151a5f6cc"><td class="memTemplParams" colspan="2">template&lt;typename Entity&gt; </td></tr>
<tr class="memitem:a5010897ed603a4eb066ea9d151a5f6cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5010897ed603a4eb066ea9d151a5f6cc">operator!=</a> (const Entity lhs, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:a5010897ed603a4eb066ea9d151a5f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an identifier of any type.  <br /></td></tr>
<tr class="separator:a5010897ed603a4eb066ea9d151a5f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf3030e5e15a6249460c9665395be79" id="r_a3bf3030e5e15a6249460c9665395be79"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename... Other&gt; </td></tr>
<tr class="memitem:a3bf3030e5e15a6249460c9665395be79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bf3030e5e15a6249460c9665395be79">operator==</a> (const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3bf3030e5e15a6249460c9665395be79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a3bf3030e5e15a6249460c9665395be79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7a84015d46560a44cf751eed96cfeb" id="r_a7c7a84015d46560a44cf751eed96cfeb"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename... Other&gt; </td></tr>
<tr class="memitem:a7c7a84015d46560a44cf751eed96cfeb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c7a84015d46560a44cf751eed96cfeb">operator!=</a> (const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7c7a84015d46560a44cf751eed96cfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a7c7a84015d46560a44cf751eed96cfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbbdfb66ed6652c8fc9e50fa0e17fcf" id="r_a4dbbdfb66ed6652c8fc9e50fa0e17fcf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4dbbdfb66ed6652c8fc9e50fa0e17fcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4dbbdfb66ed6652c8fc9e50fa0e17fcf">operator==</a> (const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="structentt_1_1null__t.html">null_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:a4dbbdfb66ed6652c8fc9e50fa0e17fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a handle with the null object.  <br /></td></tr>
<tr class="separator:a4dbbdfb66ed6652c8fc9e50fa0e17fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83884fa568c12d936d2980ff22032469" id="r_a83884fa568c12d936d2980ff22032469"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a83884fa568c12d936d2980ff22032469"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83884fa568c12d936d2980ff22032469">operator==</a> (const <a class="el" href="structentt_1_1null__t.html">null_t</a> lhs, const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a83884fa568c12d936d2980ff22032469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a handle with the null object.  <br /></td></tr>
<tr class="separator:a83884fa568c12d936d2980ff22032469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9eee8c572008fa0c43ef8e246de840" id="r_a9c9eee8c572008fa0c43ef8e246de840"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9c9eee8c572008fa0c43ef8e246de840"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c9eee8c572008fa0c43ef8e246de840">operator!=</a> (const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="structentt_1_1null__t.html">null_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9c9eee8c572008fa0c43ef8e246de840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a handle with the null object.  <br /></td></tr>
<tr class="separator:a9c9eee8c572008fa0c43ef8e246de840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae197610a7827612780de43b269557c9" id="r_aae197610a7827612780de43b269557c9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aae197610a7827612780de43b269557c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae197610a7827612780de43b269557c9">operator!=</a> (const <a class="el" href="structentt_1_1null__t.html">null_t</a> lhs, const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aae197610a7827612780de43b269557c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a handle with the null object.  <br /></td></tr>
<tr class="separator:aae197610a7827612780de43b269557c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25eea8903b4a5d58408cc2e9ecb1a2e" id="r_ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Registry = std::decay_t&lt;nth_argument_t&lt;0u, decltype(Member)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac25eea8903b4a5d58408cc2e9ecb1a2e">invoke</a> (Registry &amp;reg, const typename Registry::entity_type entt)</td></tr>
<tr class="memdesc:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a listener that directly invokes a member function.  <br /></td></tr>
<tr class="separator:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213e35d5f2e82e6c2227720e4d0857c" id="r_ae213e35d5f2e82e6c2227720e4d0857c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae213e35d5f2e82e6c2227720e4d0857c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Args... &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae213e35d5f2e82e6c2227720e4d0857c">to_entity</a> (const <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Args... &gt; &amp;<a class="el" href="#aff8fd99fc1ff2432dcb0f6b017a9c60e">storage</a>, const typename <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Args... &gt;::value_type &amp;instance)</td></tr>
<tr class="memdesc:ae213e35d5f2e82e6c2227720e4d0857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity associated with a given element.  <br /></td></tr>
<tr class="separator:ae213e35d5f2e82e6c2227720e4d0857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0050077ac79b81ac00d1d3ab66b4f53" id="r_ad0050077ac79b81ac00d1d3ab66b4f53"><td class="memTemplParams" colspan="2">template&lt;typename Registry&gt; </td></tr>
<tr class="memitem:ad0050077ac79b81ac00d1d3ab66b4f53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0050077ac79b81ac00d1d3ab66b4f53">sigh_helper</a> (Registry &amp;) -&gt; sigh_helper&lt; Registry &gt;</td></tr>
<tr class="memdesc:ad0050077ac79b81ac00d1d3ab66b4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:ad0050077ac79b81ac00d1d3ab66b4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044bc9823cac51816fc5cbcd490478d1" id="r_a044bc9823cac51816fc5cbcd490478d1"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a044bc9823cac51816fc5cbcd490478d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a044bc9823cac51816fc5cbcd490478d1">basic_view</a> (Type &amp;...<a class="el" href="#aff8fd99fc1ff2432dcb0f6b017a9c60e">storage</a>) -&gt; basic_view&lt; <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a044bc9823cac51816fc5cbcd490478d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:a044bc9823cac51816fc5cbcd490478d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb84cde1e16efe42ffc9ec956b66b4" id="r_a60bb84cde1e16efe42ffc9ec956b66b4"><td class="memTemplParams" colspan="2">template&lt;typename... Get, typename... Exclude&gt; </td></tr>
<tr class="memitem:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60bb84cde1e16efe42ffc9ec956b66b4">basic_view</a> (std::tuple&lt; Get &amp;... &gt;, std::tuple&lt; Exclude &amp;... &gt;={}) -&gt; basic_view&lt; <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Get... &gt;, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Exclude... &gt; &gt;</td></tr>
<tr class="memdesc:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb14d05375b98c803a4f335b9db15e4" id="r_a8eb14d05375b98c803a4f335b9db15e4"><td class="memTemplParams" colspan="2">template&lt;typename Graph, typename Writer&gt; </td></tr>
<tr class="memitem:a8eb14d05375b98c803a4f335b9db15e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8eb14d05375b98c803a4f335b9db15e4">dot</a> (std::ostream &amp;out, const Graph &amp;graph, Writer writer)</td></tr>
<tr class="memdesc:a8eb14d05375b98c803a4f335b9db15e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a graph in dot format.  <br /></td></tr>
<tr class="separator:a8eb14d05375b98c803a4f335b9db15e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725644b580d804e01ac6f65a927469fd" id="r_a725644b580d804e01ac6f65a927469fd"><td class="memTemplParams" colspan="2">template&lt;typename Graph&gt; </td></tr>
<tr class="memitem:a725644b580d804e01ac6f65a927469fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a725644b580d804e01ac6f65a927469fd">dot</a> (std::ostream &amp;out, const Graph &amp;graph)</td></tr>
<tr class="memdesc:a725644b580d804e01ac6f65a927469fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a graph in dot format.  <br /></td></tr>
<tr class="separator:a725644b580d804e01ac6f65a927469fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503" id="r_a2ab7b51802157a98106f238335fa7503"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ab7b51802157a98106f238335fa7503">dereference_meta_pointer_like</a> (const Type &amp;value)</td></tr>
<tr class="memdesc:a2ab7b51802157a98106f238335fa7503"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL based lookup function for dereferencing meta pointer-like types.  <br /></td></tr>
<tr class="separator:a2ab7b51802157a98106f238335fa7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7c05b6ee08bf9582e2a119dd6cbd8d" id="r_a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d7c05b6ee08bf9582e2a119dd6cbd8d">meta</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <br /></td></tr>
<tr class="separator:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78885d25ace657bedd664e3044152f03" id="r_a78885d25ace657bedd664e3044152f03"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a78885d25ace657bedd664e3044152f03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78885d25ace657bedd664e3044152f03">meta</a> () noexcept</td></tr>
<tr class="memdesc:a78885d25ace657bedd664e3044152f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <br /></td></tr>
<tr class="separator:a78885d25ace657bedd664e3044152f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a4a3ee0126a16959fcdfe6229fd057" id="r_aa4a4a3ee0126a16959fcdfe6229fd057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4a4a3ee0126a16959fcdfe6229fd057">meta_reset</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:aa4a4a3ee0126a16959fcdfe6229fd057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <br /></td></tr>
<tr class="separator:aa4a4a3ee0126a16959fcdfe6229fd057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e4b586c541f816d71ff5c23b1d2a65" id="r_af9e4b586c541f816d71ff5c23b1d2a65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9e4b586c541f816d71ff5c23b1d2a65">meta_reset</a> (const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:af9e4b586c541f816d71ff5c23b1d2a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <br /></td></tr>
<tr class="separator:af9e4b586c541f816d71ff5c23b1d2a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d262b7705ff50f3fb58d2c90b2d6b61" id="r_a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d262b7705ff50f3fb58d2c90b2d6b61">meta_reset</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <br /></td></tr>
<tr class="separator:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9a45bd7c93035354ec03dc7f196482" id="r_abe9a45bd7c93035354ec03dc7f196482"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:abe9a45bd7c93035354ec03dc7f196482"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe9a45bd7c93035354ec03dc7f196482">meta_reset</a> () noexcept</td></tr>
<tr class="memdesc:abe9a45bd7c93035354ec03dc7f196482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <br /></td></tr>
<tr class="separator:abe9a45bd7c93035354ec03dc7f196482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671352f38341177295442a0d956c9d8" id="r_a4671352f38341177295442a0d956c9d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4671352f38341177295442a0d956c9d8">meta_reset</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a4671352f38341177295442a0d956c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all meta types.  <br /></td></tr>
<tr class="separator:a4671352f38341177295442a0d956c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0484b50821691e6aacea122481c1e6" id="r_a4a0484b50821691e6aacea122481c1e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0484b50821691e6aacea122481c1e6">meta_reset</a> () noexcept</td></tr>
<tr class="memdesc:a4a0484b50821691e6aacea122481c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all meta types.  <br /></td></tr>
<tr class="separator:a4a0484b50821691e6aacea122481c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf59d78f99cd7f20904c2129088bfd7e" id="r_abf59d78f99cd7f20904c2129088bfd7e"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:abf59d78f99cd7f20904c2129088bfd7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf59d78f99cd7f20904c2129088bfd7e">forward_as_meta</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, Type &amp;&amp;value)</td></tr>
<tr class="memdesc:abf59d78f99cd7f20904c2129088bfd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <br /></td></tr>
<tr class="separator:abf59d78f99cd7f20904c2129088bfd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996" id="r_a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77c7a5a8ac08bc879abdaa00f920a996">forward_as_meta</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a77c7a5a8ac08bc879abdaa00f920a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <br /></td></tr>
<tr class="separator:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed9c972bb7bad7649ee35ec290d3456" id="r_a0ed9c972bb7bad7649ee35ec290d3456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ed9c972bb7bad7649ee35ec290d3456">operator!=</a> (const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0ed9c972bb7bad7649ee35ec290d3456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <br /></td></tr>
<tr class="separator:a0ed9c972bb7bad7649ee35ec290d3456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89afa571a2a098039702fea19dcc6882" id="r_a89afa571a2a098039702fea19dcc6882"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89afa571a2a098039702fea19dcc6882">operator!=</a> (const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a89afa571a2a098039702fea19dcc6882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <br /></td></tr>
<tr class="separator:a89afa571a2a098039702fea19dcc6882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b862c2db6e5771fb95d7a7930e9b18" id="r_a85b862c2db6e5771fb95d7a7930e9b18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85b862c2db6e5771fb95d7a7930e9b18">operator!=</a> (const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a85b862c2db6e5771fb95d7a7930e9b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <br /></td></tr>
<tr class="separator:a85b862c2db6e5771fb95d7a7930e9b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86fb3538f9ba64b4695cf45c020458e" id="r_ad86fb3538f9ba64b4695cf45c020458e"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:ad86fb3538f9ba64b4695cf45c020458e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad86fb3538f9ba64b4695cf45c020458e">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:ad86fb3538f9ba64b4695cf45c020458e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <br /></td></tr>
<tr class="separator:ad86fb3538f9ba64b4695cf45c020458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2ece8ba5dafc463abdceb1f55eaea" id="r_a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dc2ece8ba5dafc463abdceb1f55eaea">resolve</a> () noexcept</td></tr>
<tr class="memdesc:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <br /></td></tr>
<tr class="separator:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894939ee94a38b6843a8d29ab770f36a" id="r_a894939ee94a38b6843a8d29ab770f36a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7885dfa7d8e1307ff909f99182a64134">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a894939ee94a38b6843a8d29ab770f36a">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a894939ee94a38b6843a8d29ab770f36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range to use to visit all meta types.  <br /></td></tr>
<tr class="separator:a894939ee94a38b6843a8d29ab770f36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1cf09707283197b9914fa8520e7592" id="r_a1a1cf09707283197b9914fa8520e7592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7885dfa7d8e1307ff909f99182a64134">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a1cf09707283197b9914fa8520e7592">resolve</a> () noexcept</td></tr>
<tr class="memdesc:a1a1cf09707283197b9914fa8520e7592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range to use to visit all meta types.  <br /></td></tr>
<tr class="separator:a1a1cf09707283197b9914fa8520e7592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669729b83f4e0e2433cbf2a881745e22" id="r_a669729b83f4e0e2433cbf2a881745e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a669729b83f4e0e2433cbf2a881745e22">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:a669729b83f4e0e2433cbf2a881745e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <br /></td></tr>
<tr class="separator:a669729b83f4e0e2433cbf2a881745e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493a8ed8dc4bc71b11058973c0fd9aa" id="r_a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4493a8ed8dc4bc71b11058973c0fd9aa">resolve</a> (const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <br /></td></tr>
<tr class="separator:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7072f59c8738e44792806ab65c693032" id="r_a7072f59c8738e44792806ab65c693032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7072f59c8738e44792806ab65c693032">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;info) noexcept</td></tr>
<tr class="memdesc:a7072f59c8738e44792806ab65c693032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object.  <br /></td></tr>
<tr class="separator:a7072f59c8738e44792806ab65c693032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dcce4d98f6a27c4c61e814466900b2" id="r_a28dcce4d98f6a27c4c61e814466900b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28dcce4d98f6a27c4c61e814466900b2">resolve</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;info) noexcept</td></tr>
<tr class="memdesc:a28dcce4d98f6a27c4c61e814466900b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object.  <br /></td></tr>
<tr class="separator:a28dcce4d98f6a27c4c61e814466900b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f82832c0a318d045d51e4cdc3f90c7e" id="r_a8f82832c0a318d045d51e4cdc3f90c7e"><td class="memTemplParams" colspan="2">template&lt;typename Policy = as_is_t, typename Type&gt; </td></tr>
<tr class="memitem:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f82832c0a318d045d51e4cdc3f90c7e">meta_dispatch</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a value depending on the given policy.  <br /></td></tr>
<tr class="separator:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa0d4c01cb554a8c4ff29154fba457a" id="r_aefa0d4c01cb554a8c4ff29154fba457a"><td class="memTemplParams" colspan="2">template&lt;typename Policy = as_is_t, typename Type&gt; </td></tr>
<tr class="memitem:aefa0d4c01cb554a8c4ff29154fba457a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefa0d4c01cb554a8c4ff29154fba457a">meta_dispatch</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:aefa0d4c01cb554a8c4ff29154fba457a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a value depending on the given policy.  <br /></td></tr>
<tr class="separator:aefa0d4c01cb554a8c4ff29154fba457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14f35fbe2a40c6a94108b95507517fb" id="r_ac14f35fbe2a40c6a94108b95507517fb"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Data&gt; </td></tr>
<tr class="memitem:ac14f35fbe2a40c6a94108b95507517fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac14f35fbe2a40c6a94108b95507517fb">meta_setter</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> value)</td></tr>
<tr class="memdesc:ac14f35fbe2a40c6a94108b95507517fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given variable.  <br /></td></tr>
<tr class="separator:ac14f35fbe2a40c6a94108b95507517fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492632c2f27d1e0c745d73398ac534d3" id="r_a492632c2f27d1e0c745d73398ac534d3"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Data, typename Policy = as_is_t&gt; </td></tr>
<tr class="memitem:a492632c2f27d1e0c745d73398ac534d3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a492632c2f27d1e0c745d73398ac534d3">meta_getter</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:a492632c2f27d1e0c745d73398ac534d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <br /></td></tr>
<tr class="separator:a492632c2f27d1e0c745d73398ac534d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754d1db973d40e40f7b1aa6aebb7ab3" id="r_aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Data, typename Policy = as_is_t&gt; </td></tr>
<tr class="memitem:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa754d1db973d40e40f7b1aa6aebb7ab3">meta_getter</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <br /></td></tr>
<tr class="separator:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8befe85c5ee65562cff4dadac3dc00ef" id="r_a8befe85c5ee65562cff4dadac3dc00ef"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </td></tr>
<tr class="memitem:a8befe85c5ee65562cff4dadac3dc00ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8befe85c5ee65562cff4dadac3dc00ef">meta_invoke</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a8befe85c5ee65562cff4dadac3dc00ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to <em>invoke</em> an object given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a8befe85c5ee65562cff4dadac3dc00ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4a6163636762f35f9e984f1278905f" id="r_a1f4a6163636762f35f9e984f1278905f"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </td></tr>
<tr class="memitem:a1f4a6163636762f35f9e984f1278905f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f4a6163636762f35f9e984f1278905f">meta_invoke</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a1f4a6163636762f35f9e984f1278905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to <em>invoke</em> an object given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a1f4a6163636762f35f9e984f1278905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1b2e11225caa53d5880e81915e9316" id="r_aef1b2e11225caa53d5880e81915e9316"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </td></tr>
<tr class="memitem:aef1b2e11225caa53d5880e81915e9316"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef1b2e11225caa53d5880e81915e9316">meta_invoke</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:aef1b2e11225caa53d5880e81915e9316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to invoke a function given a list of erased parameters.  <br /></td></tr>
<tr class="separator:aef1b2e11225caa53d5880e81915e9316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a3b88b27196cb423e5d45eada1348" id="r_ac23a3b88b27196cb423e5d45eada1348"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </td></tr>
<tr class="memitem:ac23a3b88b27196cb423e5d45eada1348"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac23a3b88b27196cb423e5d45eada1348">meta_invoke</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:ac23a3b88b27196cb423e5d45eada1348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to invoke a function given a list of erased parameters.  <br /></td></tr>
<tr class="separator:ac23a3b88b27196cb423e5d45eada1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571cc8688ebf018c16e2a15f6c45764a" id="r_a571cc8688ebf018c16e2a15f6c45764a"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename... Args&gt; </td></tr>
<tr class="memitem:a571cc8688ebf018c16e2a15f6c45764a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a571cc8688ebf018c16e2a15f6c45764a">meta_construct</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a571cc8688ebf018c16e2a15f6c45764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a571cc8688ebf018c16e2a15f6c45764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d075524517183181aa512417358a0" id="r_a3b0d075524517183181aa512417358a0"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename... Args&gt; </td></tr>
<tr class="memitem:a3b0d075524517183181aa512417358a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b0d075524517183181aa512417358a0">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a3b0d075524517183181aa512417358a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a3b0d075524517183181aa512417358a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d052556804c409d65dcf2985dc44e2" id="r_a21d052556804c409d65dcf2985dc44e2"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </td></tr>
<tr class="memitem:a21d052556804c409d65dcf2985dc44e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21d052556804c409d65dcf2985dc44e2">meta_construct</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a21d052556804c409d65dcf2985dc44e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a21d052556804c409d65dcf2985dc44e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba2afbd0762cd23f85df6d65d6a8413" id="r_a7ba2afbd0762cd23f85df6d65d6a8413"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </td></tr>
<tr class="memitem:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ba2afbd0762cd23f85df6d65d6a8413">meta_construct</a> (Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ee2282bd9da8ef9a8b1f2c49c431b" id="r_a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </td></tr>
<tr class="memitem:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f1ee2282bd9da8ef9a8b1f2c49c431b">meta_construct</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbe3810e19337b32c66c6bab769338a" id="r_a5fbe3810e19337b32c66c6bab769338a"><td class="memTemplParams" colspan="2">template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </td></tr>
<tr class="memitem:a5fbe3810e19337b32c66c6bab769338a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5fbe3810e19337b32c66c6bab769338a">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a5fbe3810e19337b32c66c6bab769338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <br /></td></tr>
<tr class="separator:a5fbe3810e19337b32c66c6bab769338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f2adf317a555138ef5c1cf45b034a" id="r_a8b4f2adf317a555138ef5c1cf45b034a"><td class="memTemplParams" colspan="2">template&lt;std::size_t Member, typename Poly, typename... Args&gt; </td></tr>
<tr class="memitem:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b4f2adf317a555138ef5c1cf45b034a">poly_call</a> (Poly &amp;&amp;self, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8b4f2adf317a555138ef5c1cf45b034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;::invoke</code>.  <br /></td></tr>
<tr class="separator:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c12ec665a2bdc1a99e6a6298772adf" id="r_a59c12ec665a2bdc1a99e6a6298772adf"><td class="memTemplParams" colspan="2">template&lt;typename Lhs, typename Rhs&gt; </td></tr>
<tr class="memitem:a59c12ec665a2bdc1a99e6a6298772adf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59c12ec665a2bdc1a99e6a6298772adf">operator==</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a59c12ec665a2bdc1a99e6a6298772adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a59c12ec665a2bdc1a99e6a6298772adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73315d70b75d683d36c09fce559fd6d6" id="r_a73315d70b75d683d36c09fce559fd6d6"><td class="memTemplParams" colspan="2">template&lt;typename Lhs, typename Rhs&gt; </td></tr>
<tr class="memitem:a73315d70b75d683d36c09fce559fd6d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73315d70b75d683d36c09fce559fd6d6">operator!=</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a73315d70b75d683d36c09fce559fd6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a73315d70b75d683d36c09fce559fd6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514ed3fdf758d9d0cb616424d570e68d" id="r_a514ed3fdf758d9d0cb616424d570e68d"><td class="memTemplParams" colspan="2">template&lt;typename Lhs, typename Rhs&gt; </td></tr>
<tr class="memitem:a514ed3fdf758d9d0cb616424d570e68d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a514ed3fdf758d9d0cb616424d570e68d">operator&lt;</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a514ed3fdf758d9d0cb616424d570e68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a514ed3fdf758d9d0cb616424d570e68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf699fc7665abc206832e0d70d812a" id="r_a9cbf699fc7665abc206832e0d70d812a"><td class="memTemplParams" colspan="2">template&lt;typename Lhs, typename Rhs&gt; </td></tr>
<tr class="memitem:a9cbf699fc7665abc206832e0d70d812a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cbf699fc7665abc206832e0d70d812a">operator&gt;</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9cbf699fc7665abc206832e0d70d812a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a9cbf699fc7665abc206832e0d70d812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a34a8c4a32c0e4018b38dd2041417" id="r_a687a34a8c4a32c0e4018b38dd2041417"><td class="memTemplParams" colspan="2">template&lt;typename Lhs, typename Rhs&gt; </td></tr>
<tr class="memitem:a687a34a8c4a32c0e4018b38dd2041417"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a687a34a8c4a32c0e4018b38dd2041417">operator&lt;=</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a687a34a8c4a32c0e4018b38dd2041417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a687a34a8c4a32c0e4018b38dd2041417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ce0b2a8f91b438dba5febd8d79f61c" id="r_a55ce0b2a8f91b438dba5febd8d79f61c"><td class="memTemplParams" colspan="2">template&lt;typename Lhs, typename Rhs&gt; </td></tr>
<tr class="memitem:a55ce0b2a8f91b438dba5febd8d79f61c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55ce0b2a8f91b438dba5febd8d79f61c">operator&gt;=</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a55ce0b2a8f91b438dba5febd8d79f61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <br /></td></tr>
<tr class="separator:a55ce0b2a8f91b438dba5febd8d79f61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663976796b773780f6136606c1a3f31" id="r_ae663976796b773780f6136606c1a3f31"><td class="memTemplParams" colspan="2">template&lt;typename Ret, typename... Args&gt; </td></tr>
<tr class="memitem:ae663976796b773780f6136606c1a3f31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae663976796b773780f6136606c1a3f31">operator!=</a> (const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;lhs, const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae663976796b773780f6136606c1a3f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two delegates.  <br /></td></tr>
<tr class="separator:ae663976796b773780f6136606c1a3f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa5569564e913ef41b15b06e3dca0f4" id="r_acaa5569564e913ef41b15b06e3dca0f4"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:acaa5569564e913ef41b15b06e3dca0f4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acaa5569564e913ef41b15b06e3dca0f4">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;) -&gt; delegate&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt; &gt; &gt;</td></tr>
<tr class="memdesc:acaa5569564e913ef41b15b06e3dca0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:acaa5569564e913ef41b15b06e3dca0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af883efa5bf613137f825c322df3ae801" id="r_af883efa5bf613137f825c322df3ae801"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type&gt; </td></tr>
<tr class="memitem:af883efa5bf613137f825c322df3ae801"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af883efa5bf613137f825c322df3ae801">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type &amp;&amp;) -&gt; delegate&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt; &gt; &gt;</td></tr>
<tr class="memdesc:af883efa5bf613137f825c322df3ae801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:af883efa5bf613137f825c322df3ae801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c" id="r_aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplParams" colspan="2">template&lt;typename Ret, typename... Args&gt; </td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaba06006a862fa5dc613e8561ac4e92c">delegate</a> (Ret(*)(const void *, Args...), const void *=nullptr) -&gt; delegate&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:aaba06006a862fa5dc613e8561ac4e92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:aaba06006a862fa5dc613e8561ac4e92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd935c76f0b7bf40958ec43565ea157" id="r_aebd935c76f0b7bf40958ec43565ea157"><td class="memTemplParams" colspan="2">template&lt;typename Ret, typename... Args, typename Allocator&gt; </td></tr>
<tr class="memitem:aebd935c76f0b7bf40958ec43565ea157"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebd935c76f0b7bf40958ec43565ea157">sink</a> (<a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &amp;) -&gt; sink&lt; <a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &gt;</td></tr>
<tr class="memdesc:aebd935c76f0b7bf40958ec43565ea157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:aebd935c76f0b7bf40958ec43565ea157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8378b9330b5c90b6b11deee3637ebca6" id="r_a8378b9330b5c90b6b11deee3637ebca6"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a8378b9330b5c90b6b11deee3637ebca6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8378b9330b5c90b6b11deee3637ebca6">enum_as_bitmask_v</a> = <a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8378b9330b5c90b6b11deee3637ebca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a8378b9330b5c90b6b11deee3637ebca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2" id="r_ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> Value&gt; </td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab43a13f7ee60bcb0d04a001f92b86fa2">monostate_v</a> {}</td></tr>
<tr class="memdesc:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0617c69b8aa01b123162d23d7213c6aa" id="r_a0617c69b8aa01b123162d23d7213c6aa"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a0617c69b8aa01b123162d23d7213c6aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0617c69b8aa01b123162d23d7213c6aa">is_tuple_v</a> = <a class="el" href="structentt_1_1is__tuple.html">is_tuple</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a0617c69b8aa01b123162d23d7213c6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a0617c69b8aa01b123162d23d7213c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae" id="r_a089f75043b082abca3ea144bce44e9ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a089f75043b082abca3ea144bce44e9ae">choice</a> {}</td></tr>
<tr class="memdesc:a089f75043b082abca3ea144bce44e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for the choice trick.  <br /></td></tr>
<tr class="separator:a089f75043b082abca3ea144bce44e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f" id="r_a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15f9a70cbdd5a64f897a012ab2b5834f">size_of_v</a> = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7558c4e09ee416fb7fa3576737ff65" id="r_aee7558c4e09ee416fb7fa3576737ff65"><td class="memTemplParams" colspan="2">template&lt;auto Value, typename&gt; </td></tr>
<tr class="memitem:aee7558c4e09ee416fb7fa3576737ff65"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aee7558c4e09ee416fb7fa3576737ff65">unpack_as_value</a> = Value</td></tr>
<tr class="memdesc:aee7558c4e09ee416fb7fa3576737ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack.  <br /></td></tr>
<tr class="separator:aee7558c4e09ee416fb7fa3576737ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9e46d106b526d281a35901da1edea6" id="r_a3a9e46d106b526d281a35901da1edea6"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename List&gt; </td></tr>
<tr class="memitem:a3a9e46d106b526d281a35901da1edea6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a9e46d106b526d281a35901da1edea6">type_list_index_v</a> = <a class="el" href="structentt_1_1type__list__index.html">type_list_index</a>&lt;Type, List&gt;::value</td></tr>
<tr class="memdesc:a3a9e46d106b526d281a35901da1edea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a3a9e46d106b526d281a35901da1edea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c" id="r_a988ce063936d499bf2d69406c391fd5c"><td class="memTemplParams" colspan="2">template&lt;typename List, typename Type&gt; </td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a988ce063936d499bf2d69406c391fd5c">type_list_contains_v</a> = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td></tr>
<tr class="memdesc:a988ce063936d499bf2d69406c391fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a988ce063936d499bf2d69406c391fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f" id="r_a4bbfb162708696f9c1497d61573b540f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List&gt; </td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bbfb162708696f9c1497d61573b540f">value_list_element_v</a> = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td></tr>
<tr class="memdesc:a4bbfb162708696f9c1497d61573b540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <br /></td></tr>
<tr class="separator:a4bbfb162708696f9c1497d61573b540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e015c642d51a9cc31e17fea8d6f6b14" id="r_a9e015c642d51a9cc31e17fea8d6f6b14"><td class="memTemplParams" colspan="2">template&lt;auto Value, typename List&gt; </td></tr>
<tr class="memitem:a9e015c642d51a9cc31e17fea8d6f6b14"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e015c642d51a9cc31e17fea8d6f6b14">value_list_index_v</a> = <a class="el" href="structentt_1_1value__list__index.html">value_list_index</a>&lt;Value, List&gt;::value</td></tr>
<tr class="memdesc:a9e015c642d51a9cc31e17fea8d6f6b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a9e015c642d51a9cc31e17fea8d6f6b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49d414cdd708304c03606020ae5a846" id="r_ab49d414cdd708304c03606020ae5a846"><td class="memTemplParams" colspan="2">template&lt;typename List, auto Value&gt; </td></tr>
<tr class="memitem:ab49d414cdd708304c03606020ae5a846"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab49d414cdd708304c03606020ae5a846">value_list_contains_v</a> = <a class="el" href="structentt_1_1value__list__contains.html">value_list_contains</a>&lt;List, Value&gt;::value</td></tr>
<tr class="memdesc:ab49d414cdd708304c03606020ae5a846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:ab49d414cdd708304c03606020ae5a846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef" id="r_a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplParams" colspan="2">template&lt;typename Func, typename Args&gt; </td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f238620469de3ef2bafdb28fe4657ef">is_applicable_v</a> = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td></tr>
<tr class="memdesc:a4f238620469de3ef2bafdb28fe4657ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a4f238620469de3ef2bafdb28fe4657ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647" id="r_ae764716fab8c01b12d3e209004b62647"><td class="memTemplParams" colspan="2">template&lt;typename Ret, typename Func, typename Args&gt; </td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae764716fab8c01b12d3e209004b62647">is_applicable_r_v</a> = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td></tr>
<tr class="memdesc:ae764716fab8c01b12d3e209004b62647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:ae764716fab8c01b12d3e209004b62647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8" id="r_a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">is_complete_v</a> = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6" id="r_a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ac133ddb24ec535a11baf3143d188d6">is_iterator_v</a> = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a3ac133ddb24ec535a11baf3143d188d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a3ac133ddb24ec535a11baf3143d188d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b1446d23f1cba20563114f5da1f9d" id="r_afb5b1446d23f1cba20563114f5da1f9d"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:afb5b1446d23f1cba20563114f5da1f9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb5b1446d23f1cba20563114f5da1f9d">is_ebco_eligible_v</a> = <a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:afb5b1446d23f1cba20563114f5da1f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:afb5b1446d23f1cba20563114f5da1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd3998d86cc531f800d0104478771f4" id="r_a5fd3998d86cc531f800d0104478771f4"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a5fd3998d86cc531f800d0104478771f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5fd3998d86cc531f800d0104478771f4">is_transparent_v</a> = <a class="el" href="structentt_1_1is__transparent.html">is_transparent</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a5fd3998d86cc531f800d0104478771f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a5fd3998d86cc531f800d0104478771f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d" id="r_a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a068dd98a70c771935d2bf3dd96dbad6d">is_equality_comparable_v</a> = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a068dd98a70c771935d2bf3dd96dbad6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c0a1c1d953ea991591748744cdd8b" id="r_a2f0c0a1c1d953ea991591748744cdd8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f0c0a1c1d953ea991591748744cdd8b">null</a> {}</td></tr>
<tr class="memdesc:a2f0c0a1c1d953ea991591748744cdd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for null entities.  <br /></td></tr>
<tr class="separator:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674269102fdfe3fd6d7766210a828862" id="r_a674269102fdfe3fd6d7766210a828862"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a674269102fdfe3fd6d7766210a828862">tombstone</a> {}</td></tr>
<tr class="memdesc:a674269102fdfe3fd6d7766210a828862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for tombstone entities.  <br /></td></tr>
<tr class="separator:a674269102fdfe3fd6d7766210a828862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6" id="r_a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b73210cef43c4db35ef8ce477cc38a6">exclude</a> {}</td></tr>
<tr class="memdesc:a5b73210cef43c4db35ef8ce477cc38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for exclusion lists.  <br /></td></tr>
<tr class="separator:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e" id="r_a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c24ecc5ab0055f9f2a4725c95afb29e">get</a> {}</td></tr>
<tr class="memdesc:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of observed elements.  <br /></td></tr>
<tr class="separator:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ddbe2446a912714a5fe7251e25768" id="r_ac91ddbe2446a912714a5fe7251e25768"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:ac91ddbe2446a912714a5fe7251e25768"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1owned__t.html">owned_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac91ddbe2446a912714a5fe7251e25768">owned</a> {}</td></tr>
<tr class="memdesc:ac91ddbe2446a912714a5fe7251e25768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of owned elements.  <br /></td></tr>
<tr class="separator:ac91ddbe2446a912714a5fe7251e25768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7148c0f5c0a81e2c48c9d4e52d31f55" id="r_aa7148c0f5c0a81e2c48c9d4e52d31f55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1meta__ctx__arg__t.html">meta_ctx_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7148c0f5c0a81e2c48c9d4e52d31f55">meta_ctx_arg</a> {}</td></tr>
<tr class="memdesc:aa7148c0f5c0a81e2c48c9d4e52d31f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type meta_context_arg_t used to disambiguate calls.  <br /></td></tr>
<tr class="separator:aa7148c0f5c0a81e2c48c9d4e52d31f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aeaedca642d9e7220c77c7e1d2855b" id="r_a91aeaedca642d9e7220c77c7e1d2855b"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:a91aeaedca642d9e7220c77c7e1d2855b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a> = <a class="el" href="structentt_1_1is__meta__policy.html">is_meta_policy</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a91aeaedca642d9e7220c77c7e1d2855b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:a91aeaedca642d9e7220c77c7e1d2855b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c" id="r_aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa8c390cfe71301a0c10f4844e98424c">is_meta_pointer_like_v</a> = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aaa8c390cfe71301a0c10f4844e98424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <br /></td></tr>
<tr class="separator:aaa8c390cfe71301a0c10f4844e98424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142bebb2be3b87a778b1932b3a267a57" id="r_a142bebb2be3b87a778b1932b3a267a57"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:a142bebb2be3b87a778b1932b3a267a57"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a142bebb2be3b87a778b1932b3a267a57">connect_arg</a> {}</td></tr>
<tr class="memdesc:a142bebb2be3b87a778b1932b3a267a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Disambiguation tag for constructors and the like.">connect_arg_t</a> used to disambiguate calls.  <br /></td></tr>
<tr class="separator:a142bebb2be3b87a778b1932b3a267a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>EnTT</code> default namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a74619fe0ddf5ff5ea9cf98812a3d70ce" name="a74619fe0ddf5ff5ea9cf98812a3d70ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74619fe0ddf5ff5ea9cf98812a3d70ce">&#9670;&#160;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a74619fe0ddf5ff5ea9cf98812a3d70ce">entt::any</a> = <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00032">32</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="aed8389b9073df462feead9ce84ceeddb" name="aed8389b9073df462feead9ce84ceeddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8389b9073df462feead9ce84ceeddb">&#9670;&#160;</a></span>const_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aed8389b9073df462feead9ce84ceeddb">entt::const_handle</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00104">104</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a06c301e0976746f3f72b960f1c9c4675" name="a06c301e0976746f3f72b960f1c9c4675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c301e0976746f3f72b960f1c9c4675">&#9670;&#160;</a></span>const_handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a06c301e0976746f3f72b960f1c9c4675">entt::const_handle_view</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00118">118</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ac3ffdaf3a0c8ebdbb2665f9ec1d63f83" name="ac3ffdaf3a0c8ebdbb2665f9ec1d63f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ffdaf3a0c8ebdbb2665f9ec1d63f83">&#9670;&#160;</a></span>const_runtime_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac3ffdaf3a0c8ebdbb2665f9ec1d63f83">entt::const_runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt;const <a class="el" href="#af720baaca44bb4f3e4d7297777e53a2f">sparse_set</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00133">133</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a13168ef82af733bfe584f34f29472d20" name="a13168ef82af733bfe584f34f29472d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13168ef82af733bfe584f34f29472d20">&#9670;&#160;</a></span>constness_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To, typename From&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a13168ef82af733bfe584f34f29472d20">entt::constness_as_t</a> = typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt;To, From&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the transcription of the constness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to which to transcribe the constness. </td></tr>
    <tr><td class="paramname">From</td><td>The type from which to transcribe the constness. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00841">841</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ae827dd63b5553f701ae049a1cf95ef0c" name="ae827dd63b5553f701ae049a1cf95ef0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae827dd63b5553f701ae049a1cf95ef0c">&#9670;&#160;</a></span>continuous_loader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae827dd63b5553f701ae049a1cf95ef0c">entt::continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00127">127</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0a861217be8dba074e93e11eaf9bfe0c" name="a0a861217be8dba074e93e11eaf9bfe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a861217be8dba074e93e11eaf9bfe0c">&#9670;&#160;</a></span>dispatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0a861217be8dba074e93e11eaf9bfe0c">entt::dispatcher</a> = <a class="el" href="classentt_1_1basic__dispatcher.html">basic_dispatcher</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="signal_2fwd_8hpp_source.html#l00028">28</a> of file <a class="el" href="signal_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a74a376b45d5e5ea92f89da92f531975b" name="a74a376b45d5e5ea92f89da92f531975b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a376b45d5e5ea92f89da92f531975b">&#9670;&#160;</a></span>flow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a74a376b45d5e5ea92f89da92f531975b">entt::flow</a> = <a class="el" href="classentt_1_1basic__flow.html">basic_flow</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="graph_2fwd_8hpp_source.html#l00023">23</a> of file <a class="el" href="graph_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7e718d299437d564f6c3891c4c230f06" name="a7e718d299437d564f6c3891c4c230f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e718d299437d564f6c3891c4c230f06">&#9670;&#160;</a></span>group</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Owned, typename Get = get_t&lt;&gt;, typename Exclude = exclude_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7e718d299437d564f6c3891c4c230f06">entt::group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;<a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Owned, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Owned</td><td>Types of storage <em>owned</em> by the group. </td></tr>
    <tr><td class="paramname">Get</td><td>Types of storage <em>observed</em> by the group. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of storage used to filter the group. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00286">286</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a4709e4ff444e7d9b73f97d9e471bf8af" name="a4709e4ff444e7d9b73f97d9e471bf8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4709e4ff444e7d9b73f97d9e471bf8af">&#9670;&#160;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4709e4ff444e7d9b73f97d9e471bf8af">entt::handle</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00101">101</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a6f4731e2abbad1637d6fd851cf4039f6" name="a6f4731e2abbad1637d6fd851cf4039f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4731e2abbad1637d6fd851cf4039f6">&#9670;&#160;</a></span>handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6f4731e2abbad1637d6fd851cf4039f6">entt::handle_view</a> = <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00111">111</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a1a4c166c8989e0afebf8180e6c85683a" name="a1a4c166c8989e0afebf8180e6c85683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4c166c8989e0afebf8180e6c85683a">&#9670;&#160;</a></span>hashed_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1a4c166c8989e0afebf8180e6c85683a">entt::hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aliases for common character types. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00041">41</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ac577734cb888e132ce8d87efc5c28ec4" name="ac577734cb888e132ce8d87efc5c28ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac577734cb888e132ce8d87efc5c28ec4">&#9670;&#160;</a></span>hashed_wstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac577734cb888e132ce8d87efc5c28ec4">entt::hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aliases for common character types. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00044">44</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a620d583c0e6d64acf3d394524bb72303" name="a620d583c0e6d64acf3d394524bb72303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620d583c0e6d64acf3d394524bb72303">&#9670;&#160;</a></span>id_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">entt::id_type</a> = std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for type identifiers. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00029">29</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0e653af66fcdc9e4abc2a81f362b8963" name="a0e653af66fcdc9e4abc2a81f362b8963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e653af66fcdc9e4abc2a81f362b8963">&#9670;&#160;</a></span>integral_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0e653af66fcdc9e4abc2a81f362b8963">entt::integral_constant</a> = std::integral_constant&lt;decltype(Value), Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a static constant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A static constant. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00097">97</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a021c5343afb213cf29d3703cdc2c8cbc" name="a021c5343afb213cf29d3703cdc2c8cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021c5343afb213cf29d3703cdc2c8cbc">&#9670;&#160;</a></span>member_class_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Member&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a021c5343afb213cf29d3703cdc2c8cbc">entt::member_class_t</a> = typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt;Member&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>A pointer to a non-static member object or function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00870">870</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a396e96dc705319d2fc6ded344292004f" name="a396e96dc705319d2fc6ded344292004f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396e96dc705319d2fc6ded344292004f">&#9670;&#160;</a></span>meta_function_helper_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a396e96dc705319d2fc6ded344292004f">entt::meta_function_helper_t</a> = typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt;Type, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the meta function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to associate with the reflected type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00152">152</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a7885dfa7d8e1307ff909f99182a64134" name="a7885dfa7d8e1307ff909f99182a64134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7885dfa7d8e1307ff909f99182a64134">&#9670;&#160;</a></span>meta_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename It&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7885dfa7d8e1307ff909f99182a64134">entt::meta_range</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::meta_range_iterator&lt;Type, It&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterable range to use to iterate all types of meta objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of meta objects returned. </td></tr>
    <tr><td class="paramname">It</td><td>Type of forward iterator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00147">147</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a id="a1665363338d4c3e3a6b4afbec94d0d49" name="a1665363338d4c3e3a6b4afbec94d0d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1665363338d4c3e3a6b4afbec94d0d49">&#9670;&#160;</a></span>nth_argument_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1665363338d4c3e3a6b4afbec94d0d49">entt::nth_argument_t</a> = typename <a class="el" href="classentt_1_1nth__argument.html">nth_argument</a>&lt;Index, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index of the argument to extract. </td></tr>
    <tr><td class="paramname">Candidate</td><td>A valid function, member function or data member type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00905">905</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a20330b209394a912be898c964f228327" name="a20330b209394a912be898c964f228327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20330b209394a912be898c964f228327">&#9670;&#160;</a></span>organizer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a20330b209394a912be898c964f228327">entt::organizer</a> = <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00098">98</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ab6d2fe9024bafa328c5f4e4adbc96298" name="ab6d2fe9024bafa328c5f4e4adbc96298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d2fe9024bafa328c5f4e4adbc96298">&#9670;&#160;</a></span>poly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Concept&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab6d2fe9024bafa328c5f4e4adbc96298">entt::poly</a> = <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt;Concept&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concept</td><td>Concept descriptor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poly_2fwd_8hpp_source.html#l00017">17</a> of file <a class="el" href="poly_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7d9d8ddc2e43b7cda372aa52cbcc2725" name="a7d9d8ddc2e43b7cda372aa52cbcc2725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9d8ddc2e43b7cda372aa52cbcc2725">&#9670;&#160;</a></span>reactive_mixin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7d9d8ddc2e43b7cda372aa52cbcc2725">entt::reactive_mixin</a> = <a class="el" href="classentt_1_1basic__reactive__mixin.html">basic_reactive_mixin</a>&lt;Type, <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;typename Type::entity_type, typename Type::base_type::allocator_type&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Underlying storage type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00092">92</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ab8c1f492841aeafa5e75422af3f0cdc4" name="ab8c1f492841aeafa5e75422af3f0cdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c1f492841aeafa5e75422af3f0cdc4">&#9670;&#160;</a></span>registry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">entt::registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00095">95</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ae7874d535e3193cbc008ef5c7f02829d" name="ae7874d535e3193cbc008ef5c7f02829d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7874d535e3193cbc008ef5c7f02829d">&#9670;&#160;</a></span>runtime_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae7874d535e3193cbc008ef5c7f02829d">entt::runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt;<a class="el" href="#af720baaca44bb4f3e4d7297777e53a2f">sparse_set</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00130">130</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="afb4634a5b738455e0b6d35bb5444dbf4" name="afb4634a5b738455e0b6d35bb5444dbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4634a5b738455e0b6d35bb5444dbf4">&#9670;&#160;</a></span>scheduler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afb4634a5b738455e0b6d35bb5444dbf4">entt::scheduler</a> = <a class="el" href="classentt_1_1basic__scheduler.html">basic_scheduler</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="process_2fwd_8hpp_source.html#l00016">16</a> of file <a class="el" href="process_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ae235426965a236ddde9fa92979f73d5d" name="ae235426965a236ddde9fa92979f73d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae235426965a236ddde9fa92979f73d5d">&#9670;&#160;</a></span>sigh_mixin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae235426965a236ddde9fa92979f73d5d">entt::sigh_mixin</a> = <a class="el" href="classentt_1_1basic__sigh__mixin.html">basic_sigh_mixin</a>&lt;Type, <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;typename Type::entity_type, typename Type::base_type::allocator_type&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Underlying storage type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00085">85</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ae81f1e05f8be1263f14284164387c180" name="ae81f1e05f8be1263f14284164387c180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81f1e05f8be1263f14284164387c180">&#9670;&#160;</a></span>snapshot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae81f1e05f8be1263f14284164387c180">entt::snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00121">121</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="affcc892243a02aafd27f353bd810fca6" name="affcc892243a02aafd27f353bd810fca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcc892243a02aafd27f353bd810fca6">&#9670;&#160;</a></span>snapshot_loader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#affcc892243a02aafd27f353bd810fca6">entt::snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt;<a class="el" href="#ab8c1f492841aeafa5e75422af3f0cdc4">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00124">124</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="af720baaca44bb4f3e4d7297777e53a2f" name="af720baaca44bb4f3e4d7297777e53a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af720baaca44bb4f3e4d7297777e53a2f">&#9670;&#160;</a></span>sparse_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af720baaca44bb4f3e4d7297777e53a2f">entt::sparse_set</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00071">71</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="aff8fd99fc1ff2432dcb0f6b017a9c60e" name="aff8fd99fc1ff2432dcb0f6b017a9c60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8fd99fc1ff2432dcb0f6b017a9c60e">&#9670;&#160;</a></span>storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aff8fd99fc1ff2432dcb0f6b017a9c60e">entt::storage</a> = <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt;Type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00078">78</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ab7e07285e81bdf526b09a38a9618eb13" name="ab7e07285e81bdf526b09a38a9618eb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e07285e81bdf526b09a38a9618eb13">&#9670;&#160;</a></span>storage_for_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab7e07285e81bdf526b09a38a9618eb13">entt::storage_for_t</a> = typename <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Arguments to forward. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00269">269</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a12841fb02f9eaa12097dbb36251b84dd" name="a12841fb02f9eaa12097dbb36251b84dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12841fb02f9eaa12097dbb36251b84dd">&#9670;&#160;</a></span>storage_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a12841fb02f9eaa12097dbb36251b84dd">entt::storage_type_t</a> = typename <a class="el" href="structentt_1_1storage__type.html">storage_type</a>&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Arguments to forward. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00250">250</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="abdba4f06564fb96e8dfb38c272656d0a" name="abdba4f06564fb96e8dfb38c272656d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdba4f06564fb96e8dfb38c272656d0a">&#9670;&#160;</a></span>table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abdba4f06564fb96e8dfb38c272656d0a">entt::table</a> = <a class="el" href="classentt_1_1basic__table.html">basic_table</a>&lt;std::vector&lt;Type&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="container_2fwd_8hpp_source.html#l00034">34</a> of file <a class="el" href="container_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ae20502ac2073901175466d05be8a3c20" name="ae20502ac2073901175466d05be8a3c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20502ac2073901175466d05be8a3c20">&#9670;&#160;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae20502ac2073901175466d05be8a3c20">entt::tag</a> = <a class="el" href="#a0e653af66fcdc9e4abc2a81f362b8963">integral_constant</a>&lt;Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the creation of named values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A constant value at least convertible to <code><a class="el" href="#a620d583c0e6d64acf3d394524bb72303" title="Alias declaration for type identifiers.">id_type</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00104">104</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a674c50d8037ae08ac4f860e65cbfb137" name="a674c50d8037ae08ac4f860e65cbfb137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674c50d8037ae08ac4f860e65cbfb137">&#9670;&#160;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a674c50d8037ae08ac4f860e65cbfb137">entt::type_identity_t</a> = typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00054">54</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a23f80f743d8761c2ff8c6f25c8cafece" name="a23f80f743d8761c2ff8c6f25c8cafece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f80f743d8761c2ff8c6f25c8cafece">&#9670;&#160;</a></span>type_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a23f80f743d8761c2ff8c6f25c8cafece">entt::type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00252">252</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4ef0f9bd24a7cefac7835cce5744a6cd" name="a4ef0f9bd24a7cefac7835cce5744a6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef0f9bd24a7cefac7835cce5744a6cd">&#9670;&#160;</a></span>type_list_diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4ef0f9bd24a7cefac7835cce5744a6cd">entt::type_list_diff_t</a> = typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists between which to compute the difference. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00335">335</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a9ac8221f536d5ecb512dc433ec7a4fd1" name="a9ac8221f536d5ecb512dc433ec7a4fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac8221f536d5ecb512dc433ec7a4fd1">&#9670;&#160;</a></span>type_list_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9ac8221f536d5ecb512dc433ec7a4fd1">entt::type_list_element_t</a> = typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt;Index, List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the type to return. </td></tr>
    <tr><td class="paramname">List</td><td>Type list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00149">149</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a24aaff6276ebe93f2e478c4b07c40902" name="a24aaff6276ebe93f2e478c4b07c40902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aaff6276ebe93f2e478c4b07c40902">&#9670;&#160;</a></span>type_list_transform_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List, template&lt; typename... &gt; class Op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">entt::type_list_transform_t</a> = typename <a class="el" href="structentt_1_1type__list__transform.html">type_list_transform</a>&lt;List, Op&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Op</td><td>Unary operation as template class with a type member named <code>type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00359">359</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aa9ec7a62f8c682a15e93d1f928fbf8ae" name="aa9ec7a62f8c682a15e93d1f928fbf8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ec7a62f8c682a15e93d1f928fbf8ae">&#9670;&#160;</a></span>type_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa9ec7a62f8c682a15e93d1f928fbf8ae">entt::type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00287">287</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac3bd626da1438d95cf45acea68e7d5af" name="ac3bd626da1438d95cf45acea68e7d5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bd626da1438d95cf45acea68e7d5af">&#9670;&#160;</a></span>unpack_as_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac3bd626da1438d95cf45acea68e7d5af">entt::unpack_as_type</a> = Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00082">82</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3c9b49e40def274e6187d16435c79602" name="a3c9b49e40def274e6187d16435c79602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9b49e40def274e6187d16435c79602">&#9670;&#160;</a></span>value_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3c9b49e40def274e6187d16435c79602">entt::value_list_cat_t</a> = typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00517">517</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="abb1704c849f4643f1063e7ac036117f8" name="abb1704c849f4643f1063e7ac036117f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1704c849f4643f1063e7ac036117f8">&#9670;&#160;</a></span>value_list_diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abb1704c849f4643f1063e7ac036117f8">entt::value_list_diff_t</a> = typename <a class="el" href="structentt_1_1value__list__diff.html">value_list_diff</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value lists between which to compute the difference. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00597">597</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab468f1f4331cb1b664ee21fe4a22acab" name="ab468f1f4331cb1b664ee21fe4a22acab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab468f1f4331cb1b664ee21fe4a22acab">&#9670;&#160;</a></span>value_list_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab468f1f4331cb1b664ee21fe4a22acab">entt::value_list_element_t</a> = typename <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the type to return. </td></tr>
    <tr><td class="paramname">List</td><td>Value list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00406">406</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a2aac9e0d197ae6d01eb31645245a0773" name="a2aac9e0d197ae6d01eb31645245a0773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aac9e0d197ae6d01eb31645245a0773">&#9670;&#160;</a></span>value_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2aac9e0d197ae6d01eb31645245a0773">entt::value_list_unique_t</a> = typename <a class="el" href="structentt_1_1value__list__unique.html">value_list_unique</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A value list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00549">549</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3f86766cf81509c46f7009f90513d837" name="a3f86766cf81509c46f7009f90513d837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f86766cf81509c46f7009f90513d837">&#9670;&#160;</a></span>view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Get, typename Exclude = exclude_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3f86766cf81509c46f7009f90513d837">entt::view</a> = <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt;<a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="#a24aaff6276ebe93f2e478c4b07c40902">type_list_transform_t</a>&lt;Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Get</td><td>Types of storage iterated by the view. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of storage used to filter the view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00277">277</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="add777bc22ff30abfbf52abd37d4e1549" name="add777bc22ff30abfbf52abd37d4e1549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add777bc22ff30abfbf52abd37d4e1549">&#9670;&#160;</a></span>any_policy <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#add777bc22ff30abfbf52abd37d4e1549">entt::any_policy</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible modes of an any object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add777bc22ff30abfbf52abd37d4e1549aa2e4822a98337283e39f7b60acf85ec9" name="add777bc22ff30abfbf52abd37d4e1549aa2e4822a98337283e39f7b60acf85ec9"></a>empty&#160;</td><td class="fielddoc"><p>Default mode, the object does not own any elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="add777bc22ff30abfbf52abd37d4e1549ab72f3bd391ba731a35708bfd8cd8a68f" name="add777bc22ff30abfbf52abd37d4e1549ab72f3bd391ba731a35708bfd8cd8a68f"></a>dynamic&#160;</td><td class="fielddoc"><p>Owning mode, the object owns a dynamically allocated element. </p>
</td></tr>
<tr><td class="fieldname"><a id="add777bc22ff30abfbf52abd37d4e1549a605abe26d014c72e3df9deb267e73756" name="add777bc22ff30abfbf52abd37d4e1549a605abe26d014c72e3df9deb267e73756"></a>embedded&#160;</td><td class="fielddoc"><p>Owning mode, the object owns an embedded element. </p>
</td></tr>
<tr><td class="fieldname"><a id="add777bc22ff30abfbf52abd37d4e1549a18389a4a9ad5795744699cff0ba66c15" name="add777bc22ff30abfbf52abd37d4e1549a18389a4a9ad5795744699cff0ba66c15"></a>ref&#160;</td><td class="fielddoc"><p>Aliasing mode, the object <em>points</em> to a non-const element. </p>
</td></tr>
<tr><td class="fieldname"><a id="add777bc22ff30abfbf52abd37d4e1549a1e67f2ff0161fbaf51eccefa9abc6ad2" name="add777bc22ff30abfbf52abd37d4e1549a1e67f2ff0161fbaf51eccefa9abc6ad2"></a>cref&#160;</td><td class="fielddoc"><p>Const aliasing mode, the object <em>points</em> to a const element. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00011">11</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="add777bc22ff30abfbf52abd37d4e1549" name="add777bc22ff30abfbf52abd37d4e1549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add777bc22ff30abfbf52abd37d4e1549">&#9670;&#160;</a></span>any_policy <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#add777bc22ff30abfbf52abd37d4e1549">entt::any_policy</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible modes of an any object. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00011">11</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="abc4d0fa77fae26e7c01793990996c581" name="abc4d0fa77fae26e7c01793990996c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d0fa77fae26e7c01793990996c581">&#9670;&#160;</a></span>deletion_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#abc4d0fa77fae26e7c01793990996c581">entt::deletion_policy</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage deletion policy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708" name="abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708"></a>swap_and_pop&#160;</td><td class="fielddoc"><p>Swap-and-pop deletion policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28" name="abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28"></a>in_place&#160;</td><td class="fielddoc"><p>In-place deletion policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581a62044f8c7b1568e4536403704282322b" name="abc4d0fa77fae26e7c01793990996c581a62044f8c7b1568e4536403704282322b"></a>swap_only&#160;</td><td class="fielddoc"><p>Swap-only deletion policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581ad415f0e30c471dfdd9bc4f827329ef48" name="abc4d0fa77fae26e7c01793990996c581ad415f0e30c471dfdd9bc4f827329ef48"></a>unspecified&#160;</td><td class="fielddoc"><p>Unspecified deletion policy. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00017">17</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0b54e231d069e8a231e14b223388808a" name="a0b54e231d069e8a231e14b223388808a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b54e231d069e8a231e14b223388808a">&#9670;&#160;</a></span>entity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0b54e231d069e8a231e14b223388808a">entt::entity</a> : <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00014">14</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae3729f1b7699d013f982b2de2ec781f9" name="ae3729f1b7699d013f982b2de2ec781f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3729f1b7699d013f982b2de2ec781f9">&#9670;&#160;</a></span>allocate_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Allocator, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::allocate_unique </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows <code>std::unique_ptr</code> to use allocators (waiting for C++20). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to allocate for and to construct. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized unique pointer with a custom deleter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00109">109</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a12ca839d106a61776fd7f4f1041ae9ee" name="a12ca839d106a61776fd7f4f1041ae9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ca839d106a61776fd7f4f1041ae9ee">&#9670;&#160;</a></span>any_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_const_t&lt; Type &gt; entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00482">482</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a12027badfdd7739493d9a38a6c3cc913" name="a12027badfdd7739493d9a38a6c3cc913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12027badfdd7739493d9a38a6c3cc913">&#9670;&#160;</a></span>any_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_const_t&lt; Type &gt; entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00472">472</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="ae0b7dd1eaac2e05f42febf94331e1ac0" name="ae0b7dd1eaac2e05f42febf94331e1ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b7dd1eaac2e05f42febf94331e1ac0">&#9670;&#160;</a></span>any_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00505">505</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a4ce71953bc9fb5283641465fb40025dc" name="a4ce71953bc9fb5283641465fb40025dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce71953bc9fb5283641465fb40025dc">&#9670;&#160;</a></span>any_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_const_t&lt; Type &gt; entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00464">464</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="aaabf666ed024f5542f987b8b5a658f64" name="aaabf666ed024f5542f987b8b5a658f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabf666ed024f5542f987b8b5a658f64">&#9670;&#160;</a></span>any_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type * entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00498">498</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a14eb2a322b4bf420d74580c0dd71d4d9" name="a14eb2a322b4bf420d74580c0dd71d4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eb2a322b4bf420d74580c0dd71d4d9">&#9670;&#160;</a></span>basic_hashed_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::basic_hashed_string </td>
          <td>(</td>
          <td class="paramtype">const Char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) -&gt;  basic_hashed_string&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifier. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the string to hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa97361ef962166a4fc51a582d7c6392" name="aaa97361ef962166a4fc51a582d7c6392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97361ef962166a4fc51a582d7c6392">&#9670;&#160;</a></span>basic_hashed_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::basic_hashed_string </td>
          <td>(</td>
          <td class="paramtype">const Char(&amp;)</td>          <td class="paramname"><span class="paramname"><em>str</em></span>[N]</td><td>)</td>
          <td> -&gt;  basic_hashed_string&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of characters of the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60bb84cde1e16efe42ffc9ec956b66b4" name="a60bb84cde1e16efe42ffc9ec956b66b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bb84cde1e16efe42ffc9ec956b66b4">&#9670;&#160;</a></span>basic_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Get, typename... Exclude&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::basic_view </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Get &amp;... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Exclude &amp;... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) -&gt;  basic_view&lt; <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Get... &gt;, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Exclude... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Get</td><td>Types of elements iterated by the view. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of elements used to filter the view. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044bc9823cac51816fc5cbcd490478d1" name="a044bc9823cac51816fc5cbcd490478d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044bc9823cac51816fc5cbcd490478d1">&#9670;&#160;</a></span>basic_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::basic_view </td>
          <td>(</td>
          <td class="paramtype">Type &amp;...</td>          <td class="paramname"><span class="paramname"><em>storage</em></span></td><td>)</td>
          <td> -&gt;  basic_view&lt; <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of storage classes used to create the view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>The storage for the types to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd93ac21ff904a1ba357caf8ea40cd7f" name="afd93ac21ff904a1ba357caf8ea40cd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93ac21ff904a1ba357caf8ea40cd7f">&#9670;&#160;</a></span>compressed_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Other&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::compressed_pair </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  compressed_pair&lt; std::decay_t&lt; Type &gt;, std::decay_t&lt; Other &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of value to use to initialize the first element. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of value to use to initialize the second element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaa5569564e913ef41b15b06e3dca0f4" name="acaa5569564e913ef41b15b06e3dca0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa5569564e913ef41b15b06e3dca0f4">&#9670;&#160;</a></span>delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::delegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  delegate&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af883efa5bf613137f825c322df3ae801" name="af883efa5bf613137f825c322df3ae801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af883efa5bf613137f825c322df3ae801">&#9670;&#160;</a></span>delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::delegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  delegate&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba06006a862fa5dc613e8561ac4e92c" name="aaba06006a862fa5dc613e8561ac4e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba06006a862fa5dc613e8561ac4e92c">&#9670;&#160;</a></span>delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::delegate </td>
          <td>(</td>
          <td class="paramtype">Ret(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(const void *, Args...), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) -&gt;  delegate&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab7b51802157a98106f238335fa7503" name="a2ab7b51802157a98106f238335fa7503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7b51802157a98106f238335fa7503">&#9670;&#160;</a></span>dereference_meta_pointer_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::dereference_meta_pointer_like </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADL based lookup function for dereferencing meta pointer-like types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer-like object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from the dereferenced pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adl__pointer_8hpp_source.html#l00013">13</a> of file <a class="el" href="adl__pointer_8hpp_source.html">adl_pointer.hpp</a>.</p>

</div>
</div>
<a id="a725644b580d804e01ac6f65a927469fd" name="a725644b580d804e01ac6f65a927469fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725644b580d804e01ac6f65a927469fd">&#9670;&#160;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a graph in dot format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>Graph type, valid as long as it exposes edges and vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream. </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to output. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dot_8hpp_source.html#l00052">52</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a id="a8eb14d05375b98c803a4f335b9db15e4" name="a8eb14d05375b98c803a4f335b9db15e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb14d05375b98c803a4f335b9db15e4">&#9670;&#160;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename Writer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Writer</td>          <td class="paramname"><span class="paramname"><em>writer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a graph in dot format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>Graph type, valid as long as it exposes edges and vertices. </td></tr>
    <tr><td class="paramname">Writer</td><td>Vertex decorator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream. </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to output. </td></tr>
    <tr><td class="paramname">writer</td><td>Vertex decorator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dot_8hpp_source.html#l00019">19</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a id="a1ae98eeee0b0cb3e94d97d08a74a06f0" name="a1ae98eeee0b0cb3e94d97d08a74a06f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae98eeee0b0cb3e94d97d08a74a06f0">&#9670;&#160;</a></span>fast_mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, Type &gt; entt::fast_mod </td>
          <td>(</td>
          <td class="paramtype">const Type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast module utility function (powers of two only). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value of unsigned integer type. </td></tr>
    <tr><td class="paramname">mod</td><td><em>Modulus</em>, it must be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common remainder. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit_8hpp_source.html#l00063">63</a> of file <a class="el" href="bit_8hpp_source.html">bit.hpp</a>.</p>

</div>
</div>
<a id="a0662ddd2021dbf1513b7d0b40c50b9b2" name="a0662ddd2021dbf1513b7d0b40c50b9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0662ddd2021dbf1513b7d0b40c50b9b2">&#9670;&#160;</a></span>forward_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::forward_apply </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  forward_apply&lt; std::remove_reference_t&lt; std::remove_cv_t&lt; Func &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Type of underlying invocable object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af02fa96c663a6706416e47a3a6658328" name="af02fa96c663a6706416e47a3a6658328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02fa96c663a6706416e47a3a6658328">&#9670;&#160;</a></span>forward_as_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; entt::forward_as_any </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00538">538</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="abf59d78f99cd7f20904c2129088bfd7e" name="abf59d78f99cd7f20904c2129088bfd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf59d78f99cd7f20904c2129088bfd7e">&#9670;&#160;</a></span>forward_as_meta() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::forward_as_meta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00672">672</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a77c7a5a8ac08bc879abdaa00f920a996" name="a77c7a5a8ac08bc879abdaa00f920a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c7a5a8ac08bc879abdaa00f920a996">&#9670;&#160;</a></span>forward_as_meta() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::forward_as_meta </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00683">683</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a1c0d94baafb4291b7dc5a49ba6f1b0e5" name="a1c0d94baafb4291b7dc5a49ba6f1b0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0d94baafb4291b7dc5a49ba6f1b0e5">&#9670;&#160;</a></span>has_single_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, bool &gt; entt::has_single_bit </td>
          <td>(</td>
          <td class="paramtype">const Type</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a value is a power of two or not (waiting for C++20 and <code>std::has_single_bit</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value of unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is a power of two, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit_8hpp_source.html#l00031">31</a> of file <a class="el" href="bit_8hpp_source.html">bit.hpp</a>.</p>

</div>
</div>
<a id="ac25eea8903b4a5d58408cc2e9ecb1a2e" name="ac25eea8903b4a5d58408cc2e9ecb1a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25eea8903b4a5d58408cc2e9ecb1a2e">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Registry = std::decay_t&lt;nth_argument_t&lt;0u, decltype(Member)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::invoke </td>
          <td>(</td>
          <td class="paramtype">Registry &amp;</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Registry::entity_type</td>          <td class="paramname"><span class="paramname"><em>entt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a listener that directly invokes a member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Member function to invoke on an element of the given type. </td></tr>
    <tr><td class="paramname">Registry</td><td>Basic registry type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its elements. </td></tr>
    <tr><td class="paramname">entt</td><td>Entity from which to get the element. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00108">108</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="adb86dc3145589485c094960a089eb953" name="adb86dc3145589485c094960a089eb953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb86dc3145589485c094960a089eb953">&#9670;&#160;</a></span>make_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; entt::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a wrapper from a given type, passing it all arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to use to initialize the wrapper. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized wrapper for an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00525">525</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a12e4d0c58f9c4cc6f5513c39c530b9b7" name="a12e4d0c58f9c4cc6f5513c39c530b9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e4d0c58f9c4cc6f5513c39c530b9b7">&#9670;&#160;</a></span>make_obj_using_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Allocator, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::make_obj_using_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses-allocator construction utility (waiting for C++20). </p>
<p>Primarily intended for internal use. Creates an object of a given type by means of uses-allocator construction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to create. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00219">219</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a78885d25ace657bedd664e3044152f03" name="a78885d25ace657bedd664e3044152f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78885d25ace657bedd664e3044152f03">&#9670;&#160;</a></span>meta() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p>This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00535">535</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a2d7c05b6ee08bf9582e2a119dd6cbd8d" name="a2d7c05b6ee08bf9582e2a119dd6cbd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7c05b6ee08bf9582e2a119dd6cbd8d">&#9670;&#160;</a></span>meta() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p>This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context into which to construct meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00519">519</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a7ba2afbd0762cd23f85df6d65d6a8413" name="a7ba2afbd0762cd23f85df6d65d6a8413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba2afbd0762cd23f85df6d65d6a8413">&#9670;&#160;</a></span>meta_construct() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">Candidate &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00485">485</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a21d052556804c409d65dcf2985dc44e2" name="a21d052556804c409d65dcf2985dc44e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d052556804c409d65dcf2985dc44e2">&#9670;&#160;</a></span>meta_construct() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00465">465</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a571cc8688ebf018c16e2a15f6c45764a" name="a571cc8688ebf018c16e2a15f6c45764a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571cc8688ebf018c16e2a15f6c45764a">&#9670;&#160;</a></span>meta_construct() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00433">433</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a7f1ee2282bd9da8ef9a8b1f2c49c431b" name="a7f1ee2282bd9da8ef9a8b1f2c49c431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ee2282bd9da8ef9a8b1f2c49c431b">&#9670;&#160;</a></span>meta_construct() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00504">504</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3b0d075524517183181aa512417358a0" name="a3b0d075524517183181aa512417358a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0d075524517183181aa512417358a0">&#9670;&#160;</a></span>meta_construct() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00445">445</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a5fbe3810e19337b32c66c6bab769338a" name="a5fbe3810e19337b32c66c6bab769338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbe3810e19337b32c66c6bab769338a">&#9670;&#160;</a></span>meta_construct() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00517">517</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8f82832c0a318d045d51e4cdc3f90c7e" name="a8f82832c0a318d045d51e4cdc3f90c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f82832c0a318d045d51e4cdc3f90c7e">&#9670;&#160;</a></span>meta_dispatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy = as_is_t, typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps a value depending on the given policy. </p>
<p>This function always returns a wrapped value in the requested context.<br  />
 Therefore, if the passed value is itself a wrapped object with a different context, it undergoes a rebinding to the requested context.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Type</td><td>Type of value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">value</td><td>Value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00168">168</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aefa0d4c01cb554a8c4ff29154fba457a" name="aefa0d4c01cb554a8c4ff29154fba457a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa0d4c01cb554a8c4ff29154fba457a">&#9670;&#160;</a></span>meta_dispatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy = as_is_t, typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_dispatch </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps a value depending on the given policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Type</td><td>Type of value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00189">189</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aa754d1db973d40e40f7b1aa6aebb7ab3" name="aa754d1db973d40e40f7b1aa6aebb7ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa754d1db973d40e40f7b1aa6aebb7ab3">&#9670;&#160;</a></span>meta_getter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Data, typename Policy = as_is_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00355">355</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a492632c2f27d1e0c745d73398ac534d3" name="a492632c2f27d1e0c745d73398ac534d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492632c2f27d1e0c745d73398ac534d3">&#9670;&#160;</a></span>meta_getter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Data, typename Policy = as_is_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00317">317</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a1f4a6163636762f35f9e984f1278905f" name="a1f4a6163636762f35f9e984f1278905f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4a6163636762f35f9e984f1278905f">&#9670;&#160;</a></span>meta_invoke() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to <em>invoke</em> an object given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00386">386</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ac23a3b88b27196cb423e5d45eada1348" name="ac23a3b88b27196cb423e5d45eada1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a3b88b27196cb423e5d45eada1348">&#9670;&#160;</a></span>meta_invoke() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to invoke a function given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00415">415</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8befe85c5ee65562cff4dadac3dc00ef" name="a8befe85c5ee65562cff4dadac3dc00ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8befe85c5ee65562cff4dadac3dc00ef">&#9670;&#160;</a></span>meta_invoke() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Policy = as_is_t, typename Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to <em>invoke</em> an object given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00370">370</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aef1b2e11225caa53d5880e81915e9316" name="aef1b2e11225caa53d5880e81915e9316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1b2e11225caa53d5880e81915e9316">&#9670;&#160;</a></span>meta_invoke() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Candidate, typename Policy = as_is_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to invoke a function given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00400">400</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="abe9a45bd7c93035354ec03dc7f196482" name="abe9a45bd7c93035354ec03dc7f196482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9a45bd7c93035354ec03dc7f196482">&#9670;&#160;</a></span>meta_reset() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reset. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00599">599</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a4a0484b50821691e6aacea122481c1e6" name="a4a0484b50821691e6aacea122481c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0484b50821691e6aacea122481c1e6">&#9670;&#160;</a></span>meta_reset() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all meta types. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00619">619</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="af9e4b586c541f816d71ff5c23b1d2a65" name="af9e4b586c541f816d71ff5c23b1d2a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e4b586c541f816d71ff5c23b1d2a65">&#9670;&#160;</a></span>meta_reset() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<p>Resets a type and all its data members, member functions and properties, as well as its constructors, destructors and conversion functions if any.<br  />
 Base classes aren't reset but the link between the two types is removed.</p>
<p>The type is also removed from the set of searchable types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00574">574</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a3d262b7705ff50f3fb58d2c90b2d6b61" name="a3d262b7705ff50f3fb58d2c90b2d6b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d262b7705ff50f3fb58d2c90b2d6b61">&#9670;&#160;</a></span>meta_reset() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to reset meta types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00587">587</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a4671352f38341177295442a0d956c9d8" name="a4671352f38341177295442a0d956c9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4671352f38341177295442a0d956c9d8">&#9670;&#160;</a></span>meta_reset() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all meta types. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to reset meta types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00610">610</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="aa4a4a3ee0126a16959fcdfe6229fd057" name="aa4a4a3ee0126a16959fcdfe6229fd057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a4a3ee0126a16959fcdfe6229fd057">&#9670;&#160;</a></span>meta_reset() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<p>Resets a type and all its data members, member functions and properties, as well as its constructors, destructors and conversion functions if any.<br  />
 Base classes aren't reset but the link between the two types is removed.</p>
<p>The type is also removed from the set of searchable types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
    <tr><td class="paramname">ctx</td><td>The context from which to reset meta types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00551">551</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="ac14f35fbe2a40c6a94108b95507517fb" name="ac14f35fbe2a40c6a94108b95507517fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14f35fbe2a40c6a94108b95507517fb">&#9670;&#160;</a></span>meta_setter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, auto Data&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::meta_setter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">value</td><td>Parameter to use to set the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00276">276</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8f6fb41a1c8c0c5968bfca369e51a73e" name="a8f6fb41a1c8c0c5968bfca369e51a73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6fb41a1c8c0c5968bfca369e51a73e">&#9670;&#160;</a></span>next_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, Type &gt; entt::next_power_of_two </td>
          <td>(</td>
          <td class="paramtype">const Type</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest power of two greater than or equal to a value (waiting for C++20 and <code>std::bit_ceil</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value of unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest power of two greater than or equal to the given value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit_8hpp_source.html#l00043">43</a> of file <a class="el" href="bit_8hpp_source.html">bit.hpp</a>.</p>

</div>
</div>
<a id="a7c7a84015d46560a44cf751eed96cfeb" name="a7c7a84015d46560a44cf751eed96cfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7a84015d46560a44cf751eed96cfeb">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Scope of the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same registry and the same entity, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00377">377</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a9c9eee8c572008fa0c43ef8e246de840" name="a9c9eee8c572008fa0c43ef8e246de840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9eee8c572008fa0c43ef8e246de840">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a handle with the null object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00413">413</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ad9accc71a383509ada028f7fa2b767bf" name="ad9accc71a383509ada028f7fa2b767bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9accc71a383509ada028f7fa2b767bf">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00232">232</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ae663976796b773780f6136606c1a3f31" name="ae663976796b773780f6136606c1a3f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae663976796b773780f6136606c1a3f31">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two delegates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid delegate object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid delegate object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00297">297</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a9abdd7e1b2d1e98662354d5b8f691e91" name="a9abdd7e1b2d1e98662354d5b8f691e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abdd7e1b2d1e98662354d5b8f691e91">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00279">279</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a5010897ed603a4eb066ea9d151a5f6cc" name="a5010897ed603a4eb066ea9d151a5f6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5010897ed603a4eb066ea9d151a5f6cc">&#9670;&#160;</a></span>operator!=() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00364">364</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a883ee8e2a3f32a371b44e579ef0d0f25" name="a883ee8e2a3f32a371b44e579ef0d0f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ee8e2a3f32a371b44e579ef0d0f25">&#9670;&#160;</a></span>operator!=() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Value type of the iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A properly initialized iota iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>A properly initialized iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two iterators differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00131">131</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="a0ed9c972bb7bad7649ee35ec290d3456" name="a0ed9c972bb7bad7649ee35ec290d3456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed9c972bb7bad7649ee35ec290d3456">&#9670;&#160;</a></span>operator!=() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00958">958</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a89afa571a2a098039702fea19dcc6882" name="a89afa571a2a098039702fea19dcc6882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89afa571a2a098039702fea19dcc6882">&#9670;&#160;</a></span>operator!=() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01083">1083</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a85b862c2db6e5771fb95d7a7930e9b18" name="a85b862c2db6e5771fb95d7a7930e9b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b862c2db6e5771fb95d7a7930e9b18">&#9670;&#160;</a></span>operator!=() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01535">1535</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="aae197610a7827612780de43b269557c9" name="aae197610a7827612780de43b269557c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae197610a7827612780de43b269557c9">&#9670;&#160;</a></span>operator!=() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a handle with the null object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A null object yet to be converted. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00425">425</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a73315d70b75d683d36c09fce559fd6d6" name="a73315d70b75d683d36c09fce559fd6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73315d70b75d683d36c09fce559fd6d6">&#9670;&#160;</a></span>operator!=() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs, typename Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lhs</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Rhs</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same resource, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00208">208</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="afe4410448e22ae52de3bcbf262be9030" name="afe4410448e22ae52de3bcbf262be9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4410448e22ae52de3bcbf262be9030">&#9670;&#160;</a></span>operator!=() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two type info objects differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00192">192</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a6d5ebc5e9d0e87c18a22a72d2261bdf5" name="a6d5ebc5e9d0e87c18a22a72d2261bdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5ebc5e9d0e87c18a22a72d2261bdf5">&#9670;&#160;</a></span>operator&quot;&quot;_hs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1a4c166c8989e0afebf8180e6c85683a">hashed_string</a> entt::literals::operator&quot;&quot;_hs </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00294">294</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6fa5b29e7184fb8fe184417411792290" name="a6fa5b29e7184fb8fe184417411792290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa5b29e7184fb8fe184417411792290">&#9670;&#160;</a></span>operator&quot;&quot;_hws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac577734cb888e132ce8d87efc5c28ec4">hashed_wstring</a> entt::literals::operator&quot;&quot;_hws </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed wstrings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed wstring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00303">303</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ab36ceb26049f62c07817a385e35395f6" name="ab36ceb26049f62c07817a385e35395f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36ceb26049f62c07817a385e35395f6">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple type lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Types provided by the first type list. </td></tr>
    <tr><td class="paramname">Other</td><td>Types provided by the second type list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type list composed by the types of both the type lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00210">210</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a722a64074f983c827563bdd5cf7d5dde" name="a722a64074f983c827563bdd5cf7d5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722a64074f983c827563bdd5cf7d5dde">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... Value, auto... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple value lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Values provided by the first value list. </td></tr>
    <tr><td class="paramname">Other</td><td>Values provided by the second value list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value list composed by the values of both the value lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00475">475</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aa88e297d57dd5547afcde8dd291c4b8f" name="aa88e297d57dd5547afcde8dd291c4b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88e297d57dd5547afcde8dd291c4b8f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00244">244</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a514ed3fdf758d9d0cb616424d570e68d" name="a514ed3fdf758d9d0cb616424d570e68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514ed3fdf758d9d0cb616424d570e68d">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs, typename Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lhs</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Rhs</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00221">221</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="a5f6216409945594d3a50e9b8d3ad72f7" name="a5f6216409945594d3a50e9b8d3ad72f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6216409945594d3a50e9b8d3ad72f7">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00202">202</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a8c763e890bb00479a6a6aeae3b2a75f0" name="a8c763e890bb00479a6a6aeae3b2a75f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c763e890bb00479a6a6aeae3b2a75f0">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00257">257</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a687a34a8c4a32c0e4018b38dd2041417" name="a687a34a8c4a32c0e4018b38dd2041417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687a34a8c4a32c0e4018b38dd2041417">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs, typename Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lhs</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Rhs</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00248">248</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="acce5a8a6786a787daa1a656f221158cf" name="acce5a8a6786a787daa1a656f221158cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce5a8a6786a787daa1a656f221158cf">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00213">213</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a3bf3030e5e15a6249460c9665395be79" name="a3bf3030e5e15a6249460c9665395be79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf3030e5e15a6249460c9665395be79">&#9670;&#160;</a></span>operator==() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Scope of the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both handles refer to the same registry and the same entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00363">363</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a4dbbdfb66ed6652c8fc9e50fa0e17fcf" name="a4dbbdfb66ed6652c8fc9e50fa0e17fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbbdfb66ed6652c8fc9e50fa0e17fcf">&#9670;&#160;</a></span>operator==() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a handle with the null object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00389">389</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="af7c61951b721a1e3612cf536bd707501" name="af7c61951b721a1e3612cf536bd707501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c61951b721a1e3612cf536bd707501">&#9670;&#160;</a></span>operator==() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00220">220</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a60d2331ec59eb76f0304e675cfd645db" name="a60d2331ec59eb76f0304e675cfd645db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d2331ec59eb76f0304e675cfd645db">&#9670;&#160;</a></span>operator==() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00267">267</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a9332718aa52e1ebd2c22c825eec7075c" name="a9332718aa52e1ebd2c22c825eec7075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9332718aa52e1ebd2c22c825eec7075c">&#9670;&#160;</a></span>operator==() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00352">352</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a4423ccae6f6edef721acf6624b8cec41" name="a4423ccae6f6edef721acf6624b8cec41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4423ccae6f6edef721acf6624b8cec41">&#9670;&#160;</a></span>operator==() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Value type of the iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A properly initialized iota iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>A properly initialized iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two iterators are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00119">119</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="a83884fa568c12d936d2980ff22032469" name="a83884fa568c12d936d2980ff22032469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83884fa568c12d936d2980ff22032469">&#9670;&#160;</a></span>operator==() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a handle with the null object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A null object yet to be converted. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00401">401</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a59c12ec665a2bdc1a99e6a6298772adf" name="a59c12ec665a2bdc1a99e6a6298772adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c12ec665a2bdc1a99e6a6298772adf">&#9670;&#160;</a></span>operator==() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs, typename Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lhs</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Rhs</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both handles refer to the same resource, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00195">195</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="a2dcf4803e990dfe0867025bf76de501c" name="a2dcf4803e990dfe0867025bf76de501c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcf4803e990dfe0867025bf76de501c">&#9670;&#160;</a></span>operator==() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two type info objects are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00182">182</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="aec8131af000055ceab85646c14f234ad" name="aec8131af000055ceab85646c14f234ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8131af000055ceab85646c14f234ad">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00270">270</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a9cbf699fc7665abc206832e0d70d812a" name="a9cbf699fc7665abc206832e0d70d812a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbf699fc7665abc206832e0d70d812a">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs, typename Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lhs</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Rhs</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00234">234</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="abad8ef328173f0b43d96f8d042d7f444" name="abad8ef328173f0b43d96f8d042d7f444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8ef328173f0b43d96f8d042d7f444">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00224">224</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="adadb88dfb4278df554e7ffec5361ece4" name="adadb88dfb4278df554e7ffec5361ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadb88dfb4278df554e7ffec5361ece4">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00283">283</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a55ce0b2a8f91b438dba5febd8d79f61c" name="a55ce0b2a8f91b438dba5febd8d79f61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ce0b2a8f91b438dba5febd8d79f61c">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs, typename Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Lhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Rhs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lhs</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Rhs</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00262">262</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="a502743d6a5b36ceff050779d93b444ca" name="a502743d6a5b36ceff050779d93b444ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502743d6a5b36ceff050779d93b444ca">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00235">235</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a267f6d6d3ea49bd36f7e8d2f002ec1d1" name="a267f6d6d3ea49bd36f7e8d2f002ec1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f6d6d3ea49bd36f7e8d2f002ec1d1">&#9670;&#160;</a></span>overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Func *</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Function type of the desired overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A valid pointer to a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00045">45</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ac5131df9ce458a6884c43595f501f916" name="ac5131df9ce458a6884c43595f501f916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5131df9ce458a6884c43595f501f916">&#9670;&#160;</a></span>overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Class&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type Class::*</td>          <td class="paramname"><span class="paramname"><em>member</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded members of a class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the desired overload. </td></tr>
    <tr><td class="paramname">Class</td><td>Type of class to which the member belongs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>A valid pointer to a member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00034">34</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a26eb67ac302229374c5fb623d529f5eb" name="a26eb67ac302229374c5fb623d529f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eb67ac302229374c5fb623d529f5eb">&#9670;&#160;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::overloaded </td>
          <td>(</td>
          <td class="paramtype">Func...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  overloaded&lt; Func... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of function objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b4f2adf317a555138ef5c1cf45b034a" name="a8b4f2adf317a555138ef5c1cf45b034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f2adf317a555138ef5c1cf45b034a">&#9670;&#160;</a></span>poly_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Member, typename Poly, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::poly_call </td>
          <td>(</td>
          <td class="paramtype">Poly &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;::invoke</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Index of the function to invoke. </td></tr>
    <tr><td class="paramname">Poly</td><td>A fully defined poly object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A reference to the poly object that made the call. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the invoked function, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="poly_8hpp_source.html#l00173">173</a> of file <a class="el" href="poly_8hpp_source.html">poly.hpp</a>.</p>

</div>
</div>
<a id="afab136c473d8c862b183cec9d4a13915" name="afab136c473d8c862b183cec9d4a13915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab136c473d8c862b183cec9d4a13915">&#9670;&#160;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; Type &gt;, int &gt; entt::popcount </td>
          <td>(</td>
          <td class="paramtype">const Type</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in a value (waiting for C++20 and <code>std::popcount</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value of unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of set bits in the value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit_8hpp_source.html#l00019">19</a> of file <a class="el" href="bit_8hpp_source.html">bit.hpp</a>.</p>

</div>
</div>
<a id="ae934980252d1f2ce8f2473c8d74347df" name="ae934980252d1f2ce8f2473c8d74347df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae934980252d1f2ce8f2473c8d74347df">&#9670;&#160;</a></span>propagate_on_container_copy_assignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::propagate_on_container_copy_assignment </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00035">35</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a46cd263b358a2d495d4f4ee27d4537d7" name="a46cd263b358a2d495d4f4ee27d4537d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cd263b358a2d495d4f4ee27d4537d7">&#9670;&#160;</a></span>propagate_on_container_move_assignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::propagate_on_container_move_assignment </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00048">48</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a0dd7ed3d3f11933cd542d8f4646cd695" name="a0dd7ed3d3f11933cd542d8f4646cd695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd7ed3d3f11933cd542d8f4646cd695">&#9670;&#160;</a></span>propagate_on_container_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::propagate_on_container_swap </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00061">61</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a9dc2ece8ba5dafc463abdceb1f55eaea" name="a9dc2ece8ba5dafc463abdceb1f55eaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2ece8ba5dafc463abdceb1f55eaea">&#9670;&#160;</a></span>resolve() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00032">32</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a1a1cf09707283197b9914fa8520e7592" name="a1a1cf09707283197b9914fa8520e7592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1cf09707283197b9914fa8520e7592">&#9670;&#160;</a></span>resolve() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7885dfa7d8e1307ff909f99182a64134">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range to use to visit all meta types. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00050">50</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a4493a8ed8dc4bc71b11058973c0fd9aa" name="a4493a8ed8dc4bc71b11058973c0fd9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4493a8ed8dc4bc71b11058973c0fd9aa">&#9670;&#160;</a></span>resolve() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00075">75</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="ad86fb3538f9ba64b4695cf45c020458e" name="ad86fb3538f9ba64b4695cf45c020458e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86fb3538f9ba64b4695cf45c020458e">&#9670;&#160;</a></span>resolve() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00021">21</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a894939ee94a38b6843a8d29ab770f36a" name="a894939ee94a38b6843a8d29ab770f36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894939ee94a38b6843a8d29ab770f36a">&#9670;&#160;</a></span>resolve() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7885dfa7d8e1307ff909f99182a64134">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range to use to visit all meta types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00041">41</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a669729b83f4e0e2433cbf2a881745e22" name="a669729b83f4e0e2433cbf2a881745e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669729b83f4e0e2433cbf2a881745e22">&#9670;&#160;</a></span>resolve() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00060">60</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a7072f59c8738e44792806ab65c693032" name="a7072f59c8738e44792806ab65c693032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7072f59c8738e44792806ab65c693032">&#9670;&#160;</a></span>resolve() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00085">85</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a28dcce4d98f6a27c4c61e814466900b2" name="a28dcce4d98f6a27c4c61e814466900b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dcce4d98f6a27c4c61e814466900b2">&#9670;&#160;</a></span>resolve() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00096">96</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="ad0050077ac79b81ac00d1d3ab66b4f53" name="ad0050077ac79b81ac00d1d3ab66b4f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0050077ac79b81ac00d1d3ab66b4f53">&#9670;&#160;</a></span>sigh_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Registry&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::sigh_helper </td>
          <td>(</td>
          <td class="paramtype">Registry &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  sigh_helper&lt; Registry &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Registry</td><td>Basic registry type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebd935c76f0b7bf40958ec43565ea157" name="aebd935c76f0b7bf40958ec43565ea157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd935c76f0b7bf40958ec43565ea157">&#9670;&#160;</a></span>sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret, typename... Args, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">entt::sink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  sink&lt; <a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the signal handler type of a sink directly from the signal it refers to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e05563b8d3e3b61cf9b06e9e0904cc7" name="a2e05563b8d3e3b61cf9b06e9e0904cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e05563b8d3e3b61cf9b06e9e0904cc7">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First, typename Second&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two compressed pair objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">First</td><td>The type of the first element that the pairs store. </td></tr>
    <tr><td class="paramname">Second</td><td>The type of the second element that the pairs store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid compressed pair object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid compressed pair object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="compressed__pair_8hpp_source.html#l00243">243</a> of file <a class="el" href="compressed__pair_8hpp_source.html">compressed_pair.hpp</a>.</p>

</div>
</div>
<a id="af0ecb90b45a53e3272d761c237a0d850" name="af0ecb90b45a53e3272d761c237a0d850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ecb90b45a53e3272d761c237a0d850">&#9670;&#160;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::to_address </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unwraps fancy pointers, does nothing otherwise (waiting for C++20). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Fancy or raw pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer that represents the address of the original pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00020">20</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ae213e35d5f2e82e6c2227720e4d0857c" name="ae213e35d5f2e82e6c2227720e4d0857c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae213e35d5f2e82e6c2227720e4d0857c">&#9670;&#160;</a></span>to_entity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Args... &gt;::entity_type entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Args... &gt;::value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the entity associated with a given element. </p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this function only works correctly with the default storage as it makes assumptions about how the elements are laid out.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Storage type template parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>A storage that contains the given element. </td></tr>
    <tr><td class="paramname">instance</td><td>A valid element instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity associated with the given element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00126">126</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a1202b4027d32db124efffdf1f2f8c5a2" name="a1202b4027d32db124efffdf1f2f8c5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202b4027d32db124efffdf1f2f8c5a2">&#9670;&#160;</a></span>to_entity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity part once converted to the underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the entity part. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00188">188</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="ad2e252dbd8c8ebd486a3d84fbf8c2602" name="ad2e252dbd8c8ebd486a3d84fbf8c2602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e252dbd8c8ebd486a3d84fbf8c2602">&#9670;&#160;</a></span>to_integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type entt::to_integral </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an entity to its underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the given value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00177">177</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a4b7d8995ec3448ce5151309ef2281d33" name="a4b7d8995ec3448ce5151309ef2281d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7d8995ec3448ce5151309ef2281d33">&#9670;&#160;</a></span>to_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::version_type entt::to_version </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version part once converted to the underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the version part. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00199">199</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="adb9682d476edbbe4434680363f9c0eb3" name="adb9682d476edbbe4434680363f9c0eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9682d476edbbe4434680363f9c0eb3">&#9670;&#160;</a></span>type_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp; entt::type_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type info object associated to a given type. </p>
<p>The returned element refers to an object with static storage duration.<br  />
 The type doesn't need to be a complete type. If the type is a reference, the result refers to the referenced type. In all cases, top-level cv-qualifiers are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to a properly initialized type info object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00251">251</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a17387091b8374f89bfd73b2630768b53" name="a17387091b8374f89bfd73b2630768b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17387091b8374f89bfd73b2630768b53">&#9670;&#160;</a></span>type_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp; entt::type_id </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type info object associated to a given type.    </p>
<p>The returned element refers to an object with static storage duration.<br  />
 The type doesn't need to be a complete type. If the type is a reference, the result refers to the referenced type. In all cases, top-level cv-qualifiers are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to a properly initialized type info object.    </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00263">263</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a81f946567d220e7c8814636333d0cbe0" name="a81f946567d220e7c8814636333d0cbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f946567d220e7c8814636333d0cbe0">&#9670;&#160;</a></span>uninitialized_construct_using_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Allocator, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * entt::uninitialized_construct_using_allocator </td>
          <td>(</td>
          <td class="paramtype">Type *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses-allocator construction utility (waiting for C++20). </p>
<p>Primarily intended for internal use. Creates an object of a given type by means of uses-allocator construction at an uninitialized memory location.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to create. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Memory location in which to place the object. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00238">238</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="abf2665e41871f7493f674c8dbba0a593" name="abf2665e41871f7493f674c8dbba0a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2665e41871f7493f674c8dbba0a593">&#9670;&#160;</a></span>unwrap_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::unwrap_tuple </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to unwrap tuples of a single element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Tuple type of any sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A tuple object of the given type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tuple itself if it contains more than one element, the first element otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00040">40</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ac447ddab9d528647a79fd9aca429faed" name="ac447ddab9d528647a79fd9aca429faed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac447ddab9d528647a79fd9aca429faed">&#9670;&#160;</a></span>uses_allocator_construction_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Allocator, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::uses_allocator_construction_args </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses-allocator construction utility (waiting for C++20). </p>
<p>Primarily intended for internal use. Prepares the argument list needed to create an object of a given type by means of uses-allocator construction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to return arguments for. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arguments needed to create an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00201">201</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a089f75043b082abca3ea144bce44e9ae" name="a089f75043b082abca3ea144bce44e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f75043b082abca3ea144bce44e9ae">&#9670;&#160;</a></span>choice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt;N&gt; entt::choice {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for the choice trick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of choices available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00033">33</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a142bebb2be3b87a778b1932b3a267a57" name="a142bebb2be3b87a778b1932b3a267a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142bebb2be3b87a778b1932b3a267a57">&#9670;&#160;</a></span>connect_arg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt;Candidate&gt; entt::connect_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Disambiguation tag for constructors and the like.">connect_arg_t</a> used to disambiguate calls. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Element to connect (likely a free or member function). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="signal_2fwd_8hpp_source.html#l00042">42</a> of file <a class="el" href="signal_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a8378b9330b5c90b6b11deee3637ebca6" name="a8378b9330b5c90b6b11deee3637ebca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8378b9330b5c90b6b11deee3637ebca6">&#9670;&#160;</a></span>enum_as_bitmask_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::enum_as_bitmask_v = <a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The enum class type for which to enable bitmask support. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="enum_8hpp_source.html#l00024">24</a> of file <a class="el" href="enum_8hpp_source.html">enum.hpp</a>.</p>

</div>
</div>
<a id="a5b73210cef43c4db35ef8ce477cc38a6" name="a5b73210cef43c4db35ef8ce477cc38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73210cef43c4db35ef8ce477cc38a6">&#9670;&#160;</a></span>exclude</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;Type...&gt; entt::exclude {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00150">150</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a8c24ecc5ab0055f9f2a4725c95afb29e" name="a8c24ecc5ab0055f9f2a4725c95afb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c24ecc5ab0055f9f2a4725c95afb29e">&#9670;&#160;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1get__t.html">get_t</a>&lt;Type...&gt; entt::get {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of observed elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00167">167</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ae764716fab8c01b12d3e209004b62647" name="ae764716fab8c01b12d3e209004b62647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae764716fab8c01b12d3e209004b62647">&#9670;&#160;</a></span>is_applicable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret, typename Func, typename Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_applicable_r_v = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>The type to which the return type of the function should be convertible. </td></tr>
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00651">651</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4f238620469de3ef2bafdb28fe4657ef" name="a4f238620469de3ef2bafdb28fe4657ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f238620469de3ef2bafdb28fe4657ef">&#9670;&#160;</a></span>is_applicable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func, typename Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_applicable_v = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00627">627</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a8a96fcc4bc8da9a2aa1cdb0bc15b75c8" name="a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">&#9670;&#160;</a></span>is_complete_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_complete_v = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00670">670</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="afb5b1446d23f1cba20563114f5da1f9d" name="afb5b1446d23f1cba20563114f5da1f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5b1446d23f1cba20563114f5da1f9d">&#9670;&#160;</a></span>is_ebco_eligible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_ebco_eligible_v = <a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00718">718</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a068dd98a70c771935d2bf3dd96dbad6d" name="a068dd98a70c771935d2bf3dd96dbad6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068dd98a70c771935d2bf3dd96dbad6d">&#9670;&#160;</a></span>is_equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_equality_comparable_v = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00815">815</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3ac133ddb24ec535a11baf3143d188d6" name="a3ac133ddb24ec535a11baf3143d188d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac133ddb24ec535a11baf3143d188d6">&#9670;&#160;</a></span>is_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_iterator_v = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00702">702</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aaa8c390cfe71301a0c10f4844e98424c" name="aaa8c390cfe71301a0c10f4844e98424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8c390cfe71301a0c10f4844e98424c">&#9670;&#160;</a></span>is_meta_pointer_like_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::is_meta_pointer_like_v = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially pointer-like type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00050">50</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a91aeaedca642d9e7220c77c7e1d2855b" name="a91aeaedca642d9e7220c77c7e1d2855b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aeaedca642d9e7220c77c7e1d2855b">&#9670;&#160;</a></span>is_meta_policy_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_meta_policy_v = <a class="el" href="structentt_1_1is__meta__policy.html">is_meta_policy</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to check. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="policy_8hpp_source.html#l00054">54</a> of file <a class="el" href="policy_8hpp_source.html">policy.hpp</a>.</p>

</div>
</div>
<a id="a5fd3998d86cc531f800d0104478771f4" name="a5fd3998d86cc531f800d0104478771f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd3998d86cc531f800d0104478771f4">&#9670;&#160;</a></span>is_transparent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_transparent_v = <a class="el" href="structentt_1_1is__transparent.html">is_transparent</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00737">737</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a0617c69b8aa01b123162d23d7213c6aa" name="a0617c69b8aa01b123162d23d7213c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0617c69b8aa01b123162d23d7213c6aa">&#9670;&#160;</a></span>is_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::is_tuple_v = <a class="el" href="structentt_1_1is__tuple.html">is_tuple</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00030">30</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="aa7148c0f5c0a81e2c48c9d4e52d31f55" name="aa7148c0f5c0a81e2c48c9d4e52d31f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7148c0f5c0a81e2c48c9d4e52d31f55">&#9670;&#160;</a></span>meta_ctx_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__ctx__arg__t.html">meta_ctx_arg_t</a> entt::meta_ctx_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant of type meta_context_arg_t used to disambiguate calls. </p>

<p class="definition">Definition at line <a class="el" href="context_8hpp_source.html#l00031">31</a> of file <a class="el" href="context_8hpp_source.html">context.hpp</a>.</p>

</div>
</div>
<a id="ab43a13f7ee60bcb0d04a001f92b86fa2" name="ab43a13f7ee60bcb0d04a001f92b86fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43a13f7ee60bcb0d04a001f92b86fa2">&#9670;&#160;</a></span>monostate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a620d583c0e6d64acf3d394524bb72303">id_type</a> Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt;Value&gt; entt::monostate_v {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Value used to differentiate between different variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="monostate_8hpp_source.html#l00056">56</a> of file <a class="el" href="monostate_8hpp_source.html">monostate.hpp</a>.</p>

</div>
</div>
<a id="a2f0c0a1c1d953ea991591748744cdd8b" name="a2f0c0a1c1d953ea991591748744cdd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c0a1c1d953ea991591748744cdd8b">&#9670;&#160;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1null__t.html">null_t</a> entt::null {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for null entities. </p>
<p>There exist implicit conversions from this variable to identifiers of any allowed type. Similarly, there exist comparison operators between the null entity and any other identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00375">375</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="ac91ddbe2446a912714a5fe7251e25768" name="ac91ddbe2446a912714a5fe7251e25768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ddbe2446a912714a5fe7251e25768">&#9670;&#160;</a></span>owned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1owned__t.html">owned_t</a>&lt;Type...&gt; entt::owned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of owned elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00184">184</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a15f9a70cbdd5a64f897a012ab2b5834f" name="a15f9a70cbdd5a64f897a012ab2b5834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f9a70cbdd5a64f897a012ab2b5834f">&#9670;&#160;</a></span>size_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t entt::size_of_v = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of which to return the size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00074">74</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a674269102fdfe3fd6d7766210a828862" name="a674269102fdfe3fd6d7766210a828862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674269102fdfe3fd6d7766210a828862">&#9670;&#160;</a></span>tombstone</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> entt::tombstone {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for tombstone entities. </p>
<p>There exist implicit conversions from this variable to identifiers of any allowed type. Similarly, there exist comparison operators between the tombstone entity and any other identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00384">384</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a988ce063936d499bf2d69406c391fd5c" name="a988ce063936d499bf2d69406c391fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ce063936d499bf2d69406c391fd5c">&#9670;&#160;</a></span>type_list_contains_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List, typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::type_list_contains_v = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00313">313</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3a9e46d106b526d281a35901da1edea6" name="a3a9e46d106b526d281a35901da1edea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9e46d106b526d281a35901da1edea6">&#9670;&#160;</a></span>type_list_index_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t entt::type_list_index_v = <a class="el" href="structentt_1_1type__list__index.html">type_list_index</a>&lt;Type, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for and for which to return the index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00201">201</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aee7558c4e09ee416fb7fa3576737ff65" name="aee7558c4e09ee416fb7fa3576737ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7558c4e09ee416fb7fa3576737ff65">&#9670;&#160;</a></span>unpack_as_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value, typename&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::unpack_as_value = Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A value to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00090">90</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab49d414cdd708304c03606020ae5a846" name="ab49d414cdd708304c03606020ae5a846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49d414cdd708304c03606020ae5a846">&#9670;&#160;</a></span>value_list_contains_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List, auto Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::value_list_contains_v = <a class="el" href="structentt_1_1value__list__contains.html">value_list_contains</a>&lt;List, Value&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value list. </td></tr>
    <tr><td class="paramname">Value</td><td>Value to look for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00575">575</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4bbfb162708696f9c1497d61573b540f" name="a4bbfb162708696f9c1497d61573b540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfb162708696f9c1497d61573b540f">&#9670;&#160;</a></span>value_list_element_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::value_list_element_v = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the value to return. </td></tr>
    <tr><td class="paramname">List</td><td>Value list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00414">414</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a9e015c642d51a9cc31e17fea8d6f6b14" name="a9e015c642d51a9cc31e17fea8d6f6b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e015c642d51a9cc31e17fea8d6f6b14">&#9670;&#160;</a></span>value_list_index_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value, typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t entt::value_list_index_v = <a class="el" href="structentt_1_1value__list__index.html">value_list_index</a>&lt;Value, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value list. </td></tr>
    <tr><td class="paramname">Value</td><td>Value to look for and for which to return the index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00466">466</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
