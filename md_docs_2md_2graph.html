<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: Crash Course: graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EnTT<span id="projectnumber">&#160;3.15.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Crash Course: graph</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="crash-course-graph"></a></p>
<h1><a class="anchor" id="table-of-contents-5"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="md_docs_2md_2config.html#introduction">Introduction</a></li>
<li><a class="el" href="#data-structures">Data structures</a><ul>
<li><a class="el" href="#adjacency-matrix">Adjacency matrix</a></li>
<li><a class="el" href="#graphviz-dot-language">Graphviz dot language</a></li>
</ul>
</li>
<li><a class="el" href="#flow-builder">Flow builder</a><ul>
<li><a class="el" href="#tasks-and-resources">Tasks and resources</a></li>
<li><a class="el" href="#fake-resources-and-order-of-execution">Fake resources and order of execution</a></li>
<li><a class="el" href="#sync-points">Sync points</a></li>
<li><a class="el" href="#execution-graph">Execution graph</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="introduction-5"></a>
Introduction</h1>
<p><code>EnTT</code> does not aim to offer everything one needs to work with graphs. Therefore, anyone looking for this in the <em>graph</em> submodule will be disappointed.<br  />
 Quite the opposite is true though. This submodule is minimal and contains only the data structures and algorithms strictly necessary for the development of some tools such as the <em>flow builder</em>.</p>
<h1><a class="anchor" id="data-structures"></a>
Data structures</h1>
<p>As anticipated in the introduction, the aim is not to offer all possible data structures suitable for representing and working with graphs. Many will likely be added or refined over time. However, I want to discourage anyone expecting tight scheduling on the subject.<br  />
 The data structures presented in this section are mainly useful for the development and support of some tools that are also part of the same submodule.</p>
<h2><a class="anchor" id="adjacency-matrix"></a>
Adjacency matrix</h2>
<p>The adjacency matrix is designed to represent either a directed or an undirected graph:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix&lt;entt::directed_tag&gt;</a> adjacency_matrix{};</div>
<div class="ttc" id="aclassentt_1_1adjacency__matrix_html"><div class="ttname"><a href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix</a></div><div class="ttdoc">Basic implementation of a directed adjacency matrix.</div><div class="ttdef"><b>Definition</b> <a href="adjacency__matrix_8hpp_source.html#l00096">adjacency_matrix.hpp:96</a></div></div>
</div><!-- fragment --><p>The <code>directed_tag</code> type <em>creates</em> the graph as directed. There is also an <code>undirected_tag</code> counterpart which creates it as undirected.<br  />
 The interface deviates slightly from the typical double indexing of C and offers an API that is perhaps more familiar to a C++ programmer. Therefore, the access and modification of an element takes place via the <code>contains</code>, <code>insert</code> and <code>erase</code> functions rather than a double call to an <code>operator[]</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(adjacency_matrix.contains(0u, 1u)) {</div>
<div class="line">    adjacency_matrix.erase(0u, 1u);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    adjacency_matrix.insert(0u, 1u);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Both <code>insert</code> and<code>erase</code> are <em>idempotent</em> functions which have no effect if the element already exists or has already been deleted.<br  />
 The first one returns an <code>std::pair</code> containing the iterator to the element and a boolean value indicating whether the element was newly inserted or not. The second one returns the number of deleted elements (0 or 1).</p>
<p>An adjacency matrix is initialized with the number of elements (vertices) when constructing it but can also be resized later using the <code>resize</code> function:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix&lt;entt::directed_tag&gt;</a> adjacency_matrix{3u};</div>
</div><!-- fragment --><p>To visit all vertices, the class offers a function named <code>vertices</code> that returns an iterable object suitable for the purpose:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;vertex: adjacency_matrix.vertices()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The same result is obtained with the following snippet, since the vertices are plain unsigned integral values:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> last = adjacency_matrix.size(), pos = {}; pos &lt; last; ++pos) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>As for visiting the edges, a few functions are available.<br  />
 When the purpose is to visit all the edges of a given adjacency matrix, the <code>edges</code> function returns an iterable object that is used to get them as pairs of vertices:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [lhs, rhs]: adjacency_matrix.edges()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>If the goal is to visit all the in- or out-edges of a given vertex instead, the <code>in_edges</code> and <code>out_edges</code> functions are meant for that:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [lhs, rhs]: adjacency_matrix.out_edges(3u)) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Both the functions expect the vertex to visit (that is, to return the in- or out-edges for) as an argument.<br  />
 Finally, the adjacency matrix is an allocator-aware container and offers most of the functionalities one would expect from this type of containers, such as <code>clear</code> or <code>get_allocator</code> and so on.</p>
<h2><a class="anchor" id="graphviz-dot-language"></a>
Graphviz dot language</h2>
<p>As it is one of the most popular formats, the library offers minimal support for converting a graph to a Graphviz dot snippet.<br  />
 The simplest way is to pass both an output stream and a graph to the <code>dot</code> function:</p>
<div class="fragment"><div class="line">std::ostringstream output{};</div>
<div class="line"><a class="code hl_function" href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">entt::dot</a>(output, adjacency_matrix);</div>
<div class="ttc" id="anamespaceentt_html_a8eb14d05375b98c803a4f335b9db15e4"><div class="ttname"><a href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">entt::dot</a></div><div class="ttdeci">void dot(std::ostream &amp;out, const Graph &amp;graph, Writer writer)</div><div class="ttdoc">Outputs a graph in dot format.</div><div class="ttdef"><b>Definition</b> <a href="dot_8hpp_source.html#l00019">dot.hpp:19</a></div></div>
</div><!-- fragment --><p>It is also possible to provide a callback to which the vertices are passed and which can be used to add (<code>dot</code>) properties to the output as needed:</p>
<div class="fragment"><div class="line">std::ostringstream output{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">entt::dot</a>(output, adjacency_matrix, [](<span class="keyword">auto</span> &amp;output, <span class="keyword">auto</span> vertex) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;label=\&quot;v\&quot;&quot;</span> &lt;&lt; vertex &lt;&lt; <span class="stringliteral">&quot;,shape=\&quot;box\&quot;&quot;</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p>This second mode is particularly convenient when the user wants to associate externally managed data to the graph being converted.</p>
<h1><a class="anchor" id="flow-builder"></a>
Flow builder</h1>
<p>A flow builder is used to create execution graphs from tasks and resources.<br  />
 The implementation is as generic as possible and does not bind to any other part of the library.</p>
<p>This class is designed as a sort of <em>state machine</em> to which a specific task is attached for which the resources accessed in read-only or read-write mode are specified.<br  />
 Most of the functions in the API also return the flow builder itself, according to what is the common sense API when it comes to builder classes.</p>
<p>Once all tasks are registered and resources assigned to them, an execution graph in the form of an adjacency matrix is returned to the user.<br  />
 This graph contains all the tasks assigned to the flow builder in the form of <em>vertices</em>. The <em>vertex</em> itself is used as an index to get the identifier passed during registration.</p>
<h2><a class="anchor" id="tasks-and-resources"></a>
Tasks and resources</h2>
<p>Although these terms are used extensively in the documentation, the flow builder has no real concept of tasks and resources.<br  />
 This class works mainly with <em>identifiers</em>, that is, values of type <code>id_type</code>. In other terms, both tasks and resources are identified by integral values.<br  />
 This allows not to couple the class itself to the rest of the library or to any particular data structure. On the other hand, it requires the user to keep track of the association between identifiers and operations or actual data.</p>
<p>Once a flow builder is created (which requires no constructor arguments), the first thing to do is to bind a task. This tells the builder <em>who</em> intends to consume the resources that are specified immediately after:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceentt.html#a74a376b45d5e5ea92f89da92f531975b">entt::flow</a> builder{};</div>
<div class="line">builder.bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs);</div>
<div class="ttc" id="anamespaceentt_html_a74a376b45d5e5ea92f89da92f531975b"><div class="ttname"><a href="namespaceentt.html#a74a376b45d5e5ea92f89da92f531975b">entt::flow</a></div><div class="ttdeci">basic_flow&lt;&gt; flow</div><div class="ttdoc">Alias declaration for the most common use case.</div><div class="ttdef"><b>Definition</b> <a href="graph_2fwd_8hpp_source.html#l00023">fwd.hpp:23</a></div></div>
</div><!-- fragment --><p>The example uses the <code>EnTT</code> hashed string to generate an identifier for the task.<br  />
 Indeed, the use of <code>id_type</code> as an identifier type is not by accident. In fact, it matches well with the internal hashed string class. Moreover, it is also the same type returned by the hash function of the internal RTTI system, in case the user wants to rely on that.<br  />
 However, being an integral value, it leaves the user full freedom to rely on his own tools if necessary.</p>
<p>Once a task is associated with the flow builder, it has also assigned read-only or read-write resources as appropriate:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
</div><!-- fragment --><p>As mentioned, many functions return the builder itself, and it is therefore easy to concatenate the different calls.<br  />
 Also in the case of resources, they are identified by numeric values of type <code>id_type</code>. As above, the choice is not entirely random. This goes well with the tools offered by the library while leaving room for maximum flexibility.</p>
<p>Finally, both the <code>ro</code> and<code>rw</code> functions also offer an overload that accepts a pair of iterators, so that one can pass a range of resources in one go.</p>
<h3><a class="anchor" id="rebinding"></a>
Rebinding</h3>
<p>The <code>flow</code> class is resource based rather than task based. This means that graph generation is driven by resources and not by the order of <em>appearance</em> of tasks during flow definition.<br  />
 Although this concept is particularly important, it is almost irrelevant for the vast majority of cases. However, it becomes relevant when <em>rebinding</em> resources or tasks.</p>
<p>In fact, nothing prevents rebinding elements to a flow.<br  />
 However, the behavior changes slightly from case to case and has some nuances that it is worth knowing about.</p>
<p>Directly rebinding a resource without the task being replaced trivially results in the task's access mode for that resource being updated:</p>
<div class="fragment"><div class="line">builder.bind(<span class="stringliteral">&quot;task&quot;</span>_hs).rw(<span class="stringliteral">&quot;resource&quot;</span>_hs).ro(<span class="stringliteral">&quot;resource&quot;</span>_hs)</div>
</div><!-- fragment --><p>In this case, the resource is accessed in read-only mode, regardless of the first call to <code>rw</code>.<br  />
 Behind the scenes, the call does not actually <em>replace</em> the previous one but is queued after it instead, overwriting it when generating the graph. Thus, a large number of resource rebindings may even impact processing times (very difficult to observe but theoretically possible).</p>
<p>Rebinding resources and also combining it with changes to tasks has far more implications instead.<br  />
 As mentioned, graph generation takes place starting from resources and not from tasks. Therefore, the result may not be as expected:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;resource&quot;</span>_hs);</div>
</div><!-- fragment --><p>What happens here is that the resource first <em>sees</em> a read-only access request from the first task, then a read-only request from the second task and finally a read-write request from the first task.<br  />
 Although this definition would probably be counted as an error, the resulting graph may be unexpected. In fact, this consists of a single edge outgoing from the second task and directed to the first task.<br  />
 To intuitively understand what happens, it is enough to think of the fact that a task never has an edge pointing to itself.</p>
<p>While not obvious, this approach has its pros and cons like any other solution. For example, creating loops is actually simple in the context of resource-based graph generations:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;resource&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;resource&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;resource&quot;</span>_hs);</div>
</div><!-- fragment --><p>As expected, this definition leads to the creation of two edges that define a loop between the two tasks.</p>
<p>As a general rule, rebinding resources and tasks is highly discouraged because it could lead to subtle bugs if users do not know what they are doing.<br  />
 However, once the mechanisms of resource-based graph generation are understood, it can offer to the expert user flexibility and a range of possibilities otherwise inaccessible.</p>
<h2><a class="anchor" id="fake-resources-and-order-of-execution"></a>
Fake resources and order of execution</h2>
<p>The flow builder does not offer the ability to specify when a task should run before or after another task.<br  />
 In fact, the order of <em>registration</em> on the resources also determines the order in which the tasks are processed during the generation of the execution graph.</p>
<p>However, there is a way to <em>force</em> the execution order of two processes.<br  />
 Briefly, since accessing a resource in opposite modes requires sequential rather than parallel scheduling, it is possible to make use of fake resources to rule on the execution order:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_3&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
</div><!-- fragment --><p>This snippet forces the execution of <code>task_1</code> <b>before</b> <code>task_2</code> and <code>task_3</code>. This is due to the fact that the former sets a read-write requirement on a fake resource that the other tasks also want to access in read-only mode.<br  />
 Similarly, it is possible to force a task to run <b>after</b> a certain group:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_3&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
</div><!-- fragment --><p>In this case, since there are a number of processes that want to read a specific resource, they will do so in parallel by forcing <code>task_3</code> to run after all the other tasks.</p>
<h2><a class="anchor" id="sync-points"></a>
Sync points</h2>
<p>Sometimes it is useful to assign the role of <em>sync point</em> to a node.<br  />
 Whether it accesses new resources or is simply a watershed, the procedure for assigning this role to a vertex is always the same. First it is tied to the flow builder, then the <code>sync</code> function is invoked:</p>
<div class="fragment"><div class="line">builder.bind(<span class="stringliteral">&quot;sync_point&quot;</span>_hs).sync();</div>
</div><!-- fragment --><p>The choice to assign an <em>identity</em> to this type of node lies in the fact that, more often than not, they also perform operations on resources.<br  />
 If this is not the case, it will still be possible to create no-op vertices to which empty tasks are assigned.</p>
<h2><a class="anchor" id="execution-graph"></a>
Execution graph</h2>
<p>Once both the resources and their consumers have been properly registered, the purpose of this tool is to generate an execution graph that takes into account all specified constraints to return the best scheduling for the vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix&lt;entt::directed_tag&gt;</a> graph = builder.graph();</div>
</div><!-- fragment --><p>Searching for the main vertices (that is, those without in-edges) is usually the first thing required:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;vertex: graph) {</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">auto</span> in_edges = graph.in_edges(vertex); in_edges.begin() == in_edges.end()) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then it is possible to instantiate an execution graph by means of other functions such as <code>out_edges</code> to retrieve the children of a given task or <code>edges</code> to get the identifiers. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
